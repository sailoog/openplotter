#!/usr/bin/env python

# This file is part of Openplotter.
# Copyright (C) 2015 by sailoog <https://github.com/sailoog/openplotter>
#
# Openplotter is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# any later version.
# Openplotter is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Openplotter. If not, see <http://www.gnu.org/licenses/>.

import ConfigParser
import json
import os
import pyudev
import re
import requests
import subprocess
import sys
import time
import webbrowser
import wx
import wx.lib.scrolledpanel
from wx.lib.mixins.listctrl import CheckListCtrlMixin, ListCtrlAutoWidthMixin

from classes.actions import Actions
from classes.add_DS18B20 import addDS18B20
from classes.add_MCP import addMCP
from classes.add_USBinst import addUSBinst
from classes.add_action import addAction
from classes.add_gpio import addGPIO
from classes.add_kplex import addkplex
from classes.add_tool10 import addTool10
from classes.add_topic import addTopic
from classes.add_trigger import addTrigger
from classes.add_value_setting import addvaluesetting
from classes.check_vessel_self import checkVesselSelf
from classes.conf import Conf
from classes.language import Language
from classes.paths import Paths


class CheckListCtrl(wx.ListCtrl, CheckListCtrlMixin, ListCtrlAutoWidthMixin):
	def __init__(self, parent, height):
		wx.ListCtrl.__init__(self, parent, -1, style=wx.LC_REPORT | wx.SUNKEN_BORDER, size=(565, height))
		CheckListCtrlMixin.__init__(self)
		ListCtrlAutoWidthMixin.__init__(self)


class CheckListCtrl2(wx.ListCtrl, CheckListCtrlMixin, ListCtrlAutoWidthMixin):
	def __init__(self, parent, height):
		wx.ListCtrl.__init__(self, parent, -1, style=wx.LC_REPORT | wx.SUNKEN_BORDER, size=(650, height))
		CheckListCtrlMixin.__init__(self)
		ListCtrlAutoWidthMixin.__init__(self)


class MainFrame(wx.Frame):
	def __init__(self):
		self.paths = Paths()
		self.home = self.paths.home
		self.currentpath = self.paths.currentpath

		wx.Frame.__init__(self, None, title="OpenPlotter", size=(710, 460))
		if self.util_process_exist('startup.py'):
			print "System not ready, try later."
			sys.exit(0)
		self.Bind(wx.EVT_CLOSE, self.when_closed)
		self.SetFont(wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))
		self.conf = Conf(self.paths)
		self.language = self.conf.get('GENERAL', 'lang')
		self.vessel_self = checkVesselSelf()
		Language(self.language)
		self.p = wx.lib.scrolledpanel.ScrolledPanel(self, -1, style=wx.TAB_TRAVERSAL | wx.SUNKEN_BORDER)
		self.p.SetAutoLayout(1)
		self.p.SetupScrolling()
		self.nb = wx.Notebook(self.p)
		self.p_usb = wx.Panel(self.nb)
		self.p_kplex = wx.Panel(self.nb)
		self.p_n2k = wx.Panel(self.nb)
		self.p_sk = wx.Panel(self.nb)
		self.p_wifi = wx.Panel(self.nb)
		self.p_action = wx.Panel(self.nb)
		self.p_gpio = wx.Panel(self.nb)
		self.p_i2c = wx.Panel(self.nb)
		self.p_1w = wx.Panel(self.nb)
		self.p_spi = wx.Panel(self.nb)
		self.p_account = wx.Panel(self.nb)
		self.p_mqtt = wx.Panel(self.nb)
		self.p_sms = wx.Panel(self.nb)
		self.p_startup = wx.Panel(self.nb)
		self.nb.AddPage(self.p_usb, _('USB manager'))
		self.nb.AddPage(self.p_kplex, _('NMEA 0183'))
		self.nb.AddPage(self.p_n2k, _('NMEA 2K'))
		self.nb.AddPage(self.p_sk, _('Signal K'))
		self.nb.AddPage(self.p_wifi, _('WiFi AP'))
		self.nb.AddPage(self.p_action, _('Actions'))
		self.nb.AddPage(self.p_gpio, _('GPIO sensors'))
		self.nb.AddPage(self.p_i2c, _('I2C sensors'))
		self.nb.AddPage(self.p_1w, _('1W sensors'))
		self.nb.AddPage(self.p_spi, _('SPI sensors'))
		self.nb.AddPage(self.p_account, _('Accounts'))
		self.nb.AddPage(self.p_mqtt, _('MQTT'))
		self.nb.AddPage(self.p_sms, _('SMS'))
		self.nb.AddPage(self.p_startup, _('Startup'))
		sizer = wx.BoxSizer()
		sizer.Add(self.nb, 1, wx.EXPAND)
		self.p.SetSizer(sizer)
		self.icon = wx.Icon(self.currentpath + '/openplotter.ico', wx.BITMAP_TYPE_ICO)
		self.SetIcon(self.icon)
		self.CreateStatusBar()
		font_statusBar = self.GetStatusBar().GetFont()
		font_statusBar.SetWeight(wx.BOLD)
		self.GetStatusBar().SetFont(font_statusBar)
		self.GetStatusBar().SetForegroundColour(wx.BLACK)
		self.nb.Bind(wx.EVT_NOTEBOOK_PAGE_CHANGED, self.Changingpage)
		self.Centre()

		########################### menu

		self.menubar = wx.MenuBar()
		self.settings = wx.Menu()
		self.time_item1 = self.settings.Append(wx.ID_ANY, _('Set time zone'), _('Set time zone in the new window'))
		self.Bind(wx.EVT_MENU, self.time_zone, self.time_item1)
		self.time_item2 = self.settings.Append(wx.ID_ANY, _('Set time from NMEA'), _('Set system time from NMEA data'))
		self.Bind(wx.EVT_MENU, self.time_gps, self.time_item2)
		self.gpsd_item1 = self.settings.Append(wx.ID_ANY, _('Set GPSD'), _('Set GPSD in the new window'))
		self.Bind(wx.EVT_MENU, self.reconfigure_gpsd, self.gpsd_item1)
		self.settings.AppendSeparator()
		self.sdr_ais_item1 = self.settings.Append(wx.ID_ANY, _('SDR receiver'),
												  _('Set an SDR receiver in the new window'))
		self.Bind(wx.EVT_MENU, self.open_sdr_ais, self.sdr_ais_item1)
		self.calculate_item1 = self.settings.Append(wx.ID_ANY, _('Calculate'),
													_('Calculate new data from current values'))
		self.Bind(wx.EVT_MENU, self.open_calculate, self.calculate_item1)
		self.nmea_0183_item1 = self.settings.Append(wx.ID_ANY, _('NMEA 0183 generator'),
													_('Generate NMEA 0183 from current values'))
		self.Bind(wx.EVT_MENU, self.open_nmea_0183, self.nmea_0183_item1)
		self.nmea_2000_item1 = self.settings.Append(wx.ID_ANY, _('NMEA 2000 generator'),
													_('Generate NMEA 2000 from current values'))
		self.Bind(wx.EVT_MENU, self.open_nmea_2000, self.nmea_2000_item1)
		self.settings.AppendSeparator()

		self.tools_py = []
		if self.conf.has_section('TOOLS'):
			if self.conf.has_option('TOOLS', 'py'):
				data = self.conf.get('TOOLS', 'py')
				try:
					temp_list = eval(data)
				except:
					temp_list = []
				if type(temp_list) is list:
					pass
				else:
					temp_list = []
				for ii in temp_list:
					self.tools_py.append(ii)

		self.tool10_b = []
		index = 0
		for i in self.tools_py:
			self.tool10_b.append(0)
			self.tool10_b[index] = self.settings.Append(index, i[0], i[1])
			self.Bind(wx.EVT_MENU, self.tool10, self.tool10_b[index])
			index += 1
		self.menubar.Append(self.settings, _('Tools'))

		self.lang = wx.Menu()
		self.lang_item1 = self.lang.Append(wx.ID_ANY, _('English'), _('Set English language'), kind=wx.ITEM_CHECK)
		self.Bind(wx.EVT_MENU, self.lang_en, self.lang_item1)
		self.lang_item2 = self.lang.Append(wx.ID_ANY, _('Catalan'), _('Set Catalan language'), kind=wx.ITEM_CHECK)
		self.Bind(wx.EVT_MENU, self.lang_ca, self.lang_item2)
		self.lang_item3 = self.lang.Append(wx.ID_ANY, _('Spanish'), _('Set Spanish language'), kind=wx.ITEM_CHECK)
		self.Bind(wx.EVT_MENU, self.lang_es, self.lang_item3)
		self.lang_item4 = self.lang.Append(wx.ID_ANY, _('French'), _('Set French language'), kind=wx.ITEM_CHECK)
		self.Bind(wx.EVT_MENU, self.lang_fr, self.lang_item4)
		self.lang_item5 = self.lang.Append(wx.ID_ANY, _('Dutch'), _('Set Dutch language'), kind=wx.ITEM_CHECK)
		self.Bind(wx.EVT_MENU, self.lang_nl, self.lang_item5)
		self.lang_item6 = self.lang.Append(wx.ID_ANY, _('German'), _('Set German language'), kind=wx.ITEM_CHECK)
		self.Bind(wx.EVT_MENU, self.lang_de, self.lang_item6)
		self.menubar.Append(self.lang, _('Language'))

		self.helpm = wx.Menu()
		self.helpm_item1 = self.helpm.Append(wx.ID_ANY, _('&About'), _('About OpenPlotter'))
		self.Bind(wx.EVT_MENU, self.OnAboutBox, self.helpm_item1)
		self.helpm_item2 = self.helpm.Append(wx.ID_ANY, _('OpenPlotter online documentation'),
											 _('OpenPlotter online documentation'))
		self.Bind(wx.EVT_MENU, self.op_doc, self.helpm_item2)
		self.menubar.Append(self.helpm, _('&Help'))

		self.SetMenuBar(self.menubar)
		# ##########################menu
		self.page_usb()
		self.page_kplex()
		self.page_n2k()
		self.page_sk()
		self.page_wifi()
		self.page_action()
		self.page_gpio()
		self.page_i2c()
		self.page_1w()
		self.page_spi()
		self.page_account()
		self.page_mqtt()
		self.page_sms()
		self.page_startup()

		self.manual_settings = ''
		self.read_kplex_conf()
		self.SerialCheck()
		self.SerialWrongPort()
		self.read_language()

		self.read_account()
		# self.read_sk()
		self.read_sms()
		self.read_startup()
		self.read_wifi_conf()
		self.read_triggers()
		self.read_DS18B20()
		self.read_USBinst()
		self.read_gpio()
		self.read_mqtt()
		self.read_MCP()
		self.read_i2c()
		self.read_n2k()
		self.read_triggers()
		#self.when_closed(0x001)

	###########################################	general functions

	def read_language(self):
		if self.language == 'en': self.lang.Check(self.lang_item1.GetId(), True)
		if self.language == 'ca': self.lang.Check(self.lang_item2.GetId(), True)
		if self.language == 'es': self.lang.Check(self.lang_item3.GetId(), True)
		if self.language == 'fr': self.lang.Check(self.lang_item4.GetId(), True)
		if self.language == 'nl': self.lang.Check(self.lang_item5.GetId(), True)
		if self.language == 'de': self.lang.Check(self.lang_item6.GetId(), True)

	def ShowMessage(self, w_msg):
		wx.MessageBox(w_msg, 'Info', wx.OK | wx.ICON_INFORMATION)
		
	def ShowStatusBar(self, w_msg, colour):
		self.GetStatusBar().SetForegroundColour(colour)
		self.SetStatusText(w_msg)

	def ShowStatusBarRED(self, w_msg):
		self.ShowStatusBar(w_msg, wx.RED)

	def ShowStatusBarGREEN(self, w_msg):
		self.ShowStatusBar(w_msg, wx.GREEN)

	def ShowStatusBarBLACK(self, w_msg):
		self.ShowStatusBar(w_msg, wx.BLACK)	
		
	def time_zone(self, event):
		subprocess.Popen(['lxterminal', '-e', 'sudo dpkg-reconfigure tzdata'])
		self.GetStatusBar().SetForegroundColour(wx.BLACK)
		self.SetStatusText(_('Set time zone in the new window'))

	def time_gps(self, event):
		self.ShowStatusBarBLACK(_('Waiting for NMEA time data in localhost:55556 ...'))
		time_gps_result = subprocess.check_output(['sudo', 'python', self.currentpath + '/time_gps.py'])
		msg = ''
		re = time_gps_result.splitlines()
		for current in re:
			if 'Failed to connect with localhost:55556.' in current: msg += _(
				'Failed to connect with localhost:55556.\n')
			if 'Error: ' in current: msg += current + '\n'
			if 'Unable to retrieve date or time from NMEA data.' in current: msg += _(
				'Unable to retrieve date or time from NMEA data.\n')
			if 'UTC' in current:
				if not '00:00:00' in current: msg += current + '\n'
			if 'Date and time retrieved from NMEA data successfully.' in current: msg += _(
				'Date and time retrieved from NMEA data successfully.')

		self.ShowStatusBarBLACK('')
		self.ShowMessage(msg)

	def reconfigure_gpsd(self, event):
		subprocess.Popen(['lxterminal', '-e', 'sudo nano /etc/default/gpsd'])
		self.ShowStatusBarBLACK(_('Set GPSD in the new window'))

	def open_sdr_ais(self, event):
		subprocess.call(['pkill', '-f', 'SDR_AIS.py'])
		subprocess.Popen(['python', self.currentpath + '/tools/SDR_AIS.py'])

	def open_calculate(self, event):
		subprocess.call(['pkill', '-f', 'calculate.py'])
		subprocess.Popen(['python', self.currentpath + '/tools/calculate.py'])

	def open_nmea_0183(self, event):
		subprocess.call(['pkill', '-f', 'NMEA_0183_generator.py'])
		subprocess.Popen(['python', self.currentpath + '/tools/NMEA_0183_generator.py'])

	def open_nmea_2000(self, event):
		subprocess.call(['pkill', '-f', 'NMEA_2000_generator.py'])
		subprocess.Popen(['python', self.currentpath + '/tools/NMEA_2000_generator.py'])

	def tool10(self, event):
		menuId = event.Id
		dlg = addTool10()
		res = dlg.ShowModal()
		res = dlg.ButtonNr
		dlg.Destroy()
		if res != 4:
			if os.path.isfile(self.currentpath + '/tools/' + self.tools_py[menuId][2]):
				subprocess.call(['pkill', '-9', '-f', self.tools_py[menuId][2]])					
				if res == 2:
					subprocess.Popen(['python', self.currentpath + '/tools/' + self.tools_py[menuId][2]])
				elif res == 1:
					subprocess.Popen(['python', self.currentpath + '/tools/' + self.tools_py[menuId][2], 'settings'])
			else:
				print 'file not found: ', self.tools_py[menuId][2]

	def clear_lang(self):
		self.lang.Check(self.lang_item1.GetId(), False)
		self.lang.Check(self.lang_item2.GetId(), False)
		self.lang.Check(self.lang_item3.GetId(), False)
		self.lang.Check(self.lang_item4.GetId(), False)
		self.lang.Check(self.lang_item5.GetId(), False)
		self.lang.Check(self.lang_item6.GetId(), False)
		self.ShowMessage(_('The selected language will be enabled when you restart'))

	def lang_en(self, e):
		self.clear_lang()
		self.lang.Check(self.lang_item1.GetId(), True)
		self.conf.set('GENERAL', 'lang', 'en')

	def lang_ca(self, e):
		self.clear_lang()
		self.lang.Check(self.lang_item2.GetId(), True)
		self.conf.set('GENERAL', 'lang', 'ca')

	def lang_es(self, e):
		self.clear_lang()
		self.lang.Check(self.lang_item3.GetId(), True)
		self.conf.set('GENERAL', 'lang', 'es')

	def lang_fr(self, e):
		self.clear_lang()
		self.lang.Check(self.lang_item4.GetId(), True)
		self.conf.set('GENERAL', 'lang', 'fr')

	def lang_nl(self, e):
		self.clear_lang()
		self.lang.Check(self.lang_item5.GetId(), True)
		self.conf.set('GENERAL', 'lang', 'nl')

	def lang_de(self, e):
		self.clear_lang()
		self.lang.Check(self.lang_item6.GetId(), True)
		self.conf.set('GENERAL', 'lang', 'de')

	def OnAboutBox(self, e):
		description = _(
			"OpenPlotter is a DIY, open-source, low-cost, low-consumption, modular and scalable sailing platform to run on ARM boards.")
		licence = """This program is free software: you can redistribute it
and/or modify it under the terms of the GNU General Public License
as published by the Free Software Foundation, either version 2 of
the License, or any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see http://www.gnu.org/licenses/"""

		info = wx.AboutDialogInfo()
		info.SetName('OpenPlotter')
		info.SetVersion(self.conf.get('GENERAL', 'version'))
		info.SetDescription(description)
		info.SetCopyright('2016 Sailoog')
		info.SetWebSite('http://www.sailoog.com')
		info.SetLicence(licence)
		info.AddDeveloper(
			'Sailoog\nhttp://github.com/sailoog/openplotter\n-------------------\nOpenCPN: http://opencpn.org/ocpn/\nzyGrib: http://www.zygrib.org/\nMultiplexer: http://www.stripydog.com/kplex/index.html\nrtl-sdr: http://sdr.osmocom.org/trac/wiki/rtl-sdr\naisdecoder: http://www.aishub.net/aisdecoder-via-sound-card.html\ngeomag: http://github.com/cmweiss/geomag\nIMU sensor: http://github.com/richards-tech/RTIMULib2\nNMEA parser: http://github.com/Knio/pynmea2\ntwython: http://github.com/ryanmcgrath/twython\npyrtlsdr: http://github.com/roger-/pyrtlsdr\nkalibrate-rtl: http://github.com/steve-m/kalibrate-rtl\nSignalK: http://signalk.org/\n\n')
		info.AddDocWriter('Sailoog\n\nDocumentation: http://sailoog.gitbooks.io/openplotter-documentation/')
		info.AddTranslator('Catalan, English and Spanish by Sailoog\nFrench by Nicolas Janvier.')
		wx.AboutBox(info)

	def op_doc(self, e):
		url = "http://sailoog.gitbooks.io/openplotter-documentation/"
		webbrowser.open(url, new=2)

	def SerialWrongPort(self):
		try:
			self.context
		except NameError:
			self.context = pyudev.Context()

		data = self.conf.get('UDEV', 'USBinst')
		try:
			temp_list = eval(data)
		except:
			temp_list = []
		for ic in temp_list:
			if ic[5] == 'port':
				for device in self.context.list_devices(subsystem='usb'):
					dp = ""
					imi = ""
					ivi = ""
					imfd = ""
					ivfd = ""
					if 'DEVPATH' in device: dp = device['DEVPATH']
					if dp.find(ic[4]) > 0:
						if 'PRODUCT' in device:
							pr = device['PRODUCT']
							s = pr.split('/')
							imi = s[1].zfill(4)
							ivi = s[0].zfill(4)
						if imi == ic[2] and ivi == ic[1]:
							pass
						else:
							if 'ID_MODEL_FROM_DATABASE' in device:    imfd = device['ID_MODEL_FROM_DATABASE']
							if 'ID_VENDOR_FROM_DATABASE' in device:    ivfd = device['ID_VENDOR_FROM_DATABASE']
							self.ShowMessage(_('Warning: You have connected the "') + ivfd + ', ' + imfd + _(
								'" to the usb port which is reserved for another device'))

	def SerialCheck(self):
		self.SerDevLs = []
		self.context = pyudev.Context()
		for device in self.context.list_devices(subsystem='tty'):
			i = device['DEVNAME']
			if '/dev/ttyU' in i or '/dev/ttyA' in i or '/dev/ttyS' in i or '/dev/ttyO' in i or '/dev/r' in i or '/dev/i' in i:
				self.SerDevLs.append(i)
				try:
					ii = device['DEVLINKS']
					value = ii[ii.rfind('/dev/ttyOP_'):]
					if value.find('/dev/ttyOP_') >= 0:
						self.SerDevLs.append(value)
				except Exception, e:
					print str(e)
		self.can_usb.Clear()
		self.sms_dev.Clear()
		self.can_usb.AppendItems(self.SerDevLs)
		self.sms_dev.AppendItems(self.SerDevLs)

	def Changingpage(self, e):
		self.ShowStatusBarBLACK('')

	def when_closed(self, e):
		self.nb.Destroy()
		sys.exit(0)

	def util_process_exist(self, process_name):
		pids = [pid for pid in os.listdir('/proc') if pid.isdigit()]
		exist = False
		for pid in pids:
			try:
				if process_name in open(os.path.join('/proc', pid, 'cmdline'), 'rb').read():
					exist = True
			except IOError:  # proc has already terminated
				continue
			if exist:
				break
		return exist

	###########################################	startup
	def page_startup(self):
		wx.StaticBox(self.p_startup, size=(330, 50), pos=(10, 10))
		wx.StaticText(self.p_startup, label=_('Delay (seconds)'), pos=(20, 30))
		self.delay = wx.TextCtrl(self.p_startup, -1, size=(55, 32), pos=(170, 23))
		button_ok_delay = wx.Button(self.p_startup, label=_('Ok'), size=(70, 32), pos=(250, 23))
		button_ok_delay.Bind(wx.EVT_BUTTON, self.on_ok_delay)

		wx.StaticBox(self.p_startup, size=(330, 230), pos=(10, 65))
		self.startup_opencpn = wx.CheckBox(self.p_startup, label=_('OpenCPN'), pos=(20, 80))
		self.startup_opencpn.Bind(wx.EVT_CHECKBOX, self.startup)
		self.startup_opencpn_nopengl = wx.CheckBox(self.p_startup, label=_('no OpenGL'), pos=(40, 105))
		self.startup_opencpn_nopengl.Bind(wx.EVT_CHECKBOX, self.startup)
		self.startup_opencpn_fullscreen = wx.CheckBox(self.p_startup, label=_('fullscreen'), pos=(40, 130))
		self.startup_opencpn_fullscreen.Bind(wx.EVT_CHECKBOX, self.startup)

		self.startup_multiplexer = wx.CheckBox(self.p_startup, label=_('NMEA 0183 multiplexer'), pos=(20, 165))
		self.startup_multiplexer.Bind(wx.EVT_CHECKBOX, self.startup)
		self.startup_nmea_time = wx.CheckBox(self.p_startup, label=_('Set time from NMEA'), pos=(40, 190))
		self.startup_nmea_time.Bind(wx.EVT_CHECKBOX, self.startup)

		self.startup_remote_desktop = wx.CheckBox(self.p_startup, label=_('VNC remote desktop'), pos=(20, 225))
		self.startup_remote_desktop.Bind(wx.EVT_CHECKBOX, self.startup)
		self.startup_vnc_pass = wx.CheckBox(self.p_startup, label=_('use password'), pos=(40, 250))
		self.startup_vnc_pass.Bind(wx.EVT_CHECKBOX, self.startup)

		wx.StaticBox(self.p_startup, size=(330, 230), pos=(350, 65))

		self.startup_play_sound = wx.CheckBox(self.p_startup, label=_('Play sound'), pos=(360, 80))
		self.startup_play_sound.Bind(wx.EVT_CHECKBOX, self.startup)
		self.startup_path_sound = wx.TextCtrl(self.p_startup, -1, size=(200, 32), pos=(360, 110))
		self.button_select_sound = wx.Button(self.p_startup, label=_('Select'), pos=(570, 110))
		self.button_select_sound.Bind(wx.EVT_BUTTON, self.on_select_sound)

		self.op_maximize = wx.CheckBox(self.p_startup, label=_('Maximize OpenPlotter'), pos=(360, 150))
		self.op_maximize.Bind(wx.EVT_CHECKBOX, self.startup)

	def read_startup(self):
		self.delay.SetValue(self.conf.get('STARTUP', 'delay'))

		if self.conf.get('STARTUP', 'opencpn') == '1':
			self.startup_opencpn.SetValue(True)
		else:
			self.startup_opencpn_nopengl.Disable()
			self.startup_opencpn_fullscreen.Disable()
		if self.conf.get('STARTUP', 'opencpn_no_opengl') == '1': self.startup_opencpn_nopengl.SetValue(True)
		if self.conf.get('STARTUP', 'opencpn_fullscreen') == '1': self.startup_opencpn_fullscreen.SetValue(True)
		if self.conf.get('STARTUP', 'kplex') == '1':
			self.startup_multiplexer.SetValue(True)
		else:
			self.startup_nmea_time.Disable()
		if self.conf.get('STARTUP', 'gps_time') == '1': self.startup_nmea_time.SetValue(True)
		if self.conf.get('STARTUP', 'x11vnc') == '1':
			self.startup_remote_desktop.SetValue(True)
		else:
			self.startup_vnc_pass.Disable()
		if self.conf.get('STARTUP', 'vnc_pass') == '1': self.startup_vnc_pass.SetValue(True)
		if self.conf.get('STARTUP', 'maximize') == '1':
			self.op_maximize.SetValue(True)
			self.Maximize()
		self.startup_path_sound.SetValue(self.conf.get('STARTUP', 'sound'))
		if self.conf.get('STARTUP', 'play') == '1':
			self.startup_play_sound.SetValue(True)

	def on_select_sound(self, e):
		dlg = wx.FileDialog(self, message=_('Choose a file'), defaultDir=self.currentpath + '/sounds', defaultFile='',
							wildcard=_('Audio files') + ' (*.mp3)|*.mp3|' + _('All files') + ' (*.*)|*.*',
							style=wx.OPEN | wx.CHANGE_DIR)
		if dlg.ShowModal() == wx.ID_OK:
			file_path = dlg.GetPath()
			self.startup_path_sound.SetValue(file_path)
			self.conf.set('STARTUP', 'sound', file_path)
		dlg.Destroy()

	def on_ok_delay(self, e):
		delay = self.delay.GetValue()
		if not re.match('^[0-9]*$', delay):
			self.ShowStatusBarRED(_('You can enter only numbers.'))
			return
		else:
			if delay != '0': delay = delay.lstrip('0')
			self.conf.set('STARTUP', 'delay', delay)
			self.ShowStatusBarBLACK(_('Startup delay set to ') + delay + _(' seconds'))

	def startup(self, e):
		sender = e.GetEventObject()

		if sender == self.startup_opencpn:
			if self.startup_opencpn.GetValue():
				self.startup_opencpn_nopengl.Enable()
				self.startup_opencpn_fullscreen.Enable()
				self.conf.set('STARTUP', 'opencpn', '1')
			else:
				self.startup_opencpn_nopengl.Disable()
				self.startup_opencpn_fullscreen.Disable()
				self.conf.set('STARTUP', 'opencpn', '0')

		if sender == self.startup_opencpn_nopengl:
			if self.startup_opencpn_nopengl.GetValue():
				self.conf.set('STARTUP', 'opencpn_no_opengl', '1')
			else:
				self.conf.set('STARTUP', 'opencpn_no_opengl', '0')

		if sender == self.startup_opencpn_fullscreen:
			if self.startup_opencpn_fullscreen.GetValue():
				self.conf.set('STARTUP', 'opencpn_fullscreen', '1')
			else:
				self.conf.set('STARTUP', 'opencpn_fullscreen', '0')

		if sender == self.startup_multiplexer:
			if self.startup_multiplexer.GetValue():
				self.startup_nmea_time.Enable()
				self.conf.set('STARTUP', 'kplex', '1')
			else:
				self.startup_nmea_time.Disable()
				self.conf.set('STARTUP', 'kplex', '0')

		if sender == self.startup_nmea_time:
			if self.startup_nmea_time.GetValue():
				self.conf.set('STARTUP', 'gps_time', '1')
			else:
				self.conf.set('STARTUP', 'gps_time', '0')

		if sender == self.startup_remote_desktop:
			if self.startup_remote_desktop.GetValue():
				self.conf.set('STARTUP', 'x11vnc', '1')
				self.startup_vnc_pass.Enable()
			else:
				self.conf.set('STARTUP', 'x11vnc', '0')
				self.startup_vnc_pass.Disable()

		if sender == self.startup_vnc_pass:
			if self.startup_vnc_pass.GetValue():
				self.conf.set('STARTUP', 'vnc_pass', '1')
				dlg = wx.MessageDialog(None, _('Do you want to change your VNC-Password?'), _('Question'),
									   wx.YES_NO | wx.NO_DEFAULT | wx.ICON_QUESTION)
				if dlg.ShowModal() == wx.ID_YES:
					subprocess.Popen(['lxterminal', '-e', 'x11vnc', '-storepasswd'])
				dlg.Destroy()
			else:
				self.conf.set('STARTUP', 'vnc_pass', '0')

		if sender == self.op_maximize:
			if self.op_maximize.GetValue():
				self.conf.set('STARTUP', 'maximize', '1')
			else:
				self.conf.set('STARTUP', 'maximize', '0')

		if sender == self.startup_play_sound:
			if self.startup_play_sound.GetValue():
				self.conf.set('STARTUP', 'play', '1')
			else:
				self.conf.set('STARTUP', 'play', '0')

				########################################### WiFi AP

	def page_wifi(self):
		wx.StaticBox(self.p_wifi, size=(370, 315), pos=(10, 10))
		self.wifi_enable = wx.CheckBox(self.p_wifi, label=_('Enable access point'), pos=(20, 25))
		self.wifi_enable.Bind(wx.EVT_CHECKBOX, self.onwifi_enable)

		self.bridge_enable = wx.CheckBox(self.p_wifi, label=_('Enable bridge to eth0'), pos=(180, 25))

		self.available_wireless = []
		output = subprocess.check_output('ifconfig')
		for i in range(0, 9):
			ii = str(i)
			if 'wlan' + ii in output: self.available_wireless.append('wlan' + ii)

		self.available_wireless_AP = []
		for i in self.available_wireless:
			try:
				output2 = subprocess.check_output(['iw', i, 'info'], stderr=subprocess.STDOUT)
			except:
				output2 = ''
			if output2 != '':
				startpos = output2.find('wiphy') + 5
				iwphy = int(output2[startpos:startpos + 3])
				output2 = subprocess.check_output(['iw', 'phy' + str(iwphy), 'info'], stderr=subprocess.STDOUT)
				startpos = output2.find('Supported interface modes')
				if 'AP' in output2[startpos:startpos + 80]:
					self.available_wireless_AP.append(i)

		self.available_share = [_('none')]
		for i in range(0, 9):
			ii = str(i)
			if 'eth' + ii in output: self.available_share.append('eth' + ii)
			if 'ppp' + ii in output: self.available_share.append('ppp' + ii)
			if 'usb' + ii in output: self.available_share.append('usb' + ii)
		for i in self.available_wireless:
			self.available_share.append(i)
		share_old = self.conf.get('WIFI', 'share')
		if share_old != '0' and share_old not in self.available_share: self.available_share.append(share_old)
		self.wlan_label = wx.StaticText(self.p_wifi, label=_('Access point device'), pos=(20, 55))
		self.wlan = wx.ComboBox(self.p_wifi, choices=self.available_wireless_AP, style=wx.CB_READONLY, size=(100, 32),
								pos=(20, 75))

		self.share_label = wx.StaticText(self.p_wifi, label=_('Sharing Internet device'), pos=(180, 55))
		self.share = wx.ComboBox(self.p_wifi, choices=self.available_share, style=wx.CB_READONLY, size=(100, 32),
								 pos=(180, 75))

		self.wifi_settings_label = wx.StaticText(self.p_wifi, label=_('Access point settings'), pos=(20, 120))

		self.ssid = wx.TextCtrl(self.p_wifi, -1, size=(120, 32), pos=(20, 140))
		self.ssid_label = wx.StaticText(self.p_wifi, label=_('SSID \nmaximum 32 characters'), pos=(160, 140))

		self.passw = wx.TextCtrl(self.p_wifi, -1, size=(120, 32), pos=(20, 173))
		self.passw_label = wx.StaticText(self.p_wifi, label=_('Password \nminimum 8 characters required'),
										 pos=(160, 175))

		self.wifi_channel_list = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13']
		self.wifi_channel = wx.ComboBox(self.p_wifi, choices=self.wifi_channel_list, style=wx.CB_READONLY,
										size=(120, 32), pos=(20, 208))
		self.wifi_channel_label = wx.StaticText(self.p_wifi, label=_('Channel'), pos=(160, 215))

		self.wifi_mode_list = ['IEEE 802.11b', 'IEEE 802.11g']
		self.wifi_mode = wx.ComboBox(self.p_wifi, choices=self.wifi_mode_list, style=wx.CB_READONLY, size=(120, 32),
									 pos=(20, 246))
		self.wifi_mode_label = wx.StaticText(self.p_wifi, label=_('Mode'), pos=(160, 255))

		self.wifi_wpa_list = ['None', 'WPA', 'WPA2', _('Both')]
		self.wifi_wpa = wx.ComboBox(self.p_wifi, choices=self.wifi_wpa_list, style=wx.CB_READONLY, size=(120, 32),
									pos=(20, 285))
		self.wifi_wpa_label = wx.StaticText(self.p_wifi, label=_('WPA'), pos=(160, 290))

		self.wifi_button_default = wx.Button(self.p_wifi, label=_('Defaults'), pos=(275, 280))
		self.wifi_button_default.Bind(wx.EVT_BUTTON, self.on_wifi_default)

		wx.StaticBox(self.p_wifi, label=_(' Addresses '), size=(290, 315), pos=(385, 10))
		self.ip_info = wx.TextCtrl(self.p_wifi, -1, style=wx.TE_MULTILINE | wx.TE_READONLY, size=(270, 245),
								   pos=(395, 30))
		self.ip_info.SetBackgroundColour(wx.SystemSettings_GetColour(wx.SYS_COLOUR_INACTIVECAPTION))

		self.button_refresh_ip = wx.Button(self.p_wifi, label=_('Refresh'), pos=(565, 280))
		self.button_refresh_ip.Bind(wx.EVT_BUTTON, self.on_show_ip_info)

		self.check_net_b = wx.Button(self.p_wifi, label=_('Status'), pos=(465, 280))
		self.check_net_b.Bind(wx.EVT_BUTTON, self.on_check_net)

	def read_wifi_conf(self):
		if len(self.available_wireless) > 0:
			self.wlan.SetValue(self.conf.get('WIFI', 'device'))
			self.ssid.SetValue(self.conf.get('WIFI', 'ssid'))
			self.wifi_channel.SetValue(self.conf.get('WIFI', 'channel'))
			if self.conf.get('WIFI', 'password'): self.passw.SetValue('**********')
			if self.conf.get('WIFI', 'share') == '0':
				self.share.SetValue(_('none'))
			else:
				self.share.SetValue(self.conf.get('WIFI', 'share'))
			if self.conf.get('WIFI', 'hw_mode') == 'b': self.wifi_mode.SetValue('IEEE 802.11b')
			if self.conf.get('WIFI', 'hw_mode') == 'g': self.wifi_mode.SetValue('IEEE 802.11g')
			if self.conf.get('WIFI', 'wpa') == '0': self.wifi_wpa.SetValue('None')
			if self.conf.get('WIFI', 'wpa') == '1': self.wifi_wpa.SetValue('WPA')
			if self.conf.get('WIFI', 'wpa') == '2': self.wifi_wpa.SetValue('WPA2')
			if self.conf.get('WIFI', 'wpa') == '3': self.wifi_wpa.SetValue(_('Both'))
			if self.conf.get('WIFI', 'bridge') == '1':
				self.bridge_enable.SetValue(True)
			else:
				self.bridge_enable.SetValue(False)
			if self.conf.get('WIFI', 'enable') == '1':
				self.enable_disable_wifi(1)
		else:
			self.enable_disable_wifi(0)
		self.on_show_ip_info('')

	def onwifi_enable(self, e):
		isChecked = self.wifi_enable.GetValue()
		if not isChecked:
			dlg = wx.MessageDialog(None, _(
				'Are you sure to disable?\nIf you are connected by remote, you may not be able to reconnect again.'),
								   _('Question'), wx.YES_NO | wx.NO_DEFAULT | wx.ICON_QUESTION)
			if dlg.ShowModal() != wx.ID_YES:
				self.wifi_enable.SetValue(True)
				dlg.Destroy()
				return
			dlg.Destroy()
		wlan = self.wlan.GetValue()
		ssid = self.ssid.GetValue()
		share = self.share.GetValue()
		if '*****' in self.passw.GetValue():
			passw = self.conf.get('WIFI', 'password')
		else:
			passw = self.passw.GetValue()

		if not wlan or not passw or not ssid or not share:
			self.ShowStatusBarRED(_('Failed. You must fill in all fields.'))
			self.enable_disable_wifi(0)
			return
		if wlan == share:
			self.ShowStatusBarRED(_('"Access point device" and "Sharing Internet device" must be different'))
			self.enable_disable_wifi(0)
			return
		if len(ssid) > 32 or len(passw) < 8:
			self.ShowStatusBarRED(_('Your SSID must have a maximum of 32 characters and your password a minimum of 8.'))
			self.enable_disable_wifi(0)
			return
		self.ShowStatusBarRED(_('Configuring WiFi AP, wait please ...'))
		channel = self.wifi_channel.GetValue()
		mode = self.wifi_mode.GetValue()
		wpa = self.wifi_wpa.GetValue()
		bridge = '0'
		if self.bridge_enable.GetValue(): bridge = '1'
		if share == _('none'): share = '0'
		if mode == 'IEEE 802.11b': mode = 'b'
		if mode == 'IEEE 802.11g': mode = 'g'
		if wpa == 'None': wpa = '0'
		if wpa == 'WPA': wpa = '1'
		if wpa == 'WPA2': wpa = '2'
		if wpa == _('Both'): wpa = '3'
		self.conf.set('WIFI', 'device', wlan)
		self.conf.set('WIFI', 'password', passw)
		self.conf.set('WIFI', 'ssid', ssid)
		self.conf.set('WIFI', 'share', share)
		self.conf.set('WIFI', 'channel', channel)
		self.conf.set('WIFI', 'hw_mode', mode)
		self.conf.set('WIFI', 'wpa', wpa)
		self.conf.set('WIFI', 'bridge', bridge)
		self.passw.SetValue('**********')
		if isChecked:
			self.enable_disable_wifi(1)
			wifi_result = subprocess.check_output(['sudo', 'python', self.currentpath + '/wifi_server.py', '1'])
		else:
			self.enable_disable_wifi(0)
			wifi_result = subprocess.check_output(['sudo', 'python', self.currentpath + '/wifi_server.py', '0'])
		msg = wifi_result
		if 'WiFi access point failed.' in msg:
			self.enable_disable_wifi(0)
		msg = msg.replace('WiFi access point failed.', _('WiFi access point failed.'))
		msg = msg.replace('WiFi access point started.', _('WiFi access point started.'))
		msg = msg.replace('WiFi access point stopped.', _('WiFi access point stopped.'))
		self.ShowStatusBarBLACK('')
		self.ShowMessage(msg)
		self.on_show_ip_info('')

	def on_show_ip_info(self, e):
		ip_info = subprocess.check_output(['hostname', '-I'])
		out = _(' Multiplexed NMEA 0183:\n')
		ips = ip_info.split()
		for ip in ips:
			out += ip + ':55556\n'
		out += _('\n VNC remote desktop:\n')
		for ip in ips:
			out += ip + ':5900\n'
		out += _('\n RDP remote desktop:\n')
		for ip in ips:
			out += ip + '\n'
		out += _('\n MQTT local broker:\n')
		for ip in ips:
			out += ip + ':1883\n'
		out += _('\n Signal K panel:\n')
		for ip in ips:
			out += ip + ':3000/instrumentpanel\n'
		out += _('\n Signal K gauge:\n')
		for ip in ips:
			out += ip + ':3000/sailgauge\n'
		out += _('\n Signal K NMEA 0183:\n')
		for ip in ips:
			out += ip + ':10111\n'
		self.ip_info.SetValue(out)

	def on_check_net(self, e):
		msg = ''
		msg1 = ''
		network_info = ''
		try:
			network_info = subprocess.check_output('iw wlan0 info'.split())
		except:
			pass
		if 'AP' in network_info: msg1 += 'wlan0 is AP'
		network_info = ''
		try:
			network_info = subprocess.check_output('iw wlan1 info'.split())
		except:
			pass
		if 'AP' in network_info: msg1 += 'wlan1 is AP'
		if msg1 == '': msg1 += 'missing AP! or driver is not nl80211'
		msg += msg1 + '\n'

		msg1 = ''
		network_info = ''
		try:
			network_info = subprocess.check_output('ifconfig'.split())
		except:
			pass
		for i in network_info.split('\n'):
			if 'wlan0' in i: msg1 += 'wlan0 '
			if 'wlan1' in i: msg1 += 'wlan1 '
		msg += 'up network: ' + msg1 + '\n'

		msg1 = ''
		network_info = ''
		try:
			network_info = subprocess.check_output('service dnsmasq status'.split())
		except:
			pass
		for i in network_info.split('\n'):
			if 'running' in i: msg1 += 'running'
		if msg1 == '': msg1 += 'stopped'
		msg += 'dnsmasq (dhcp-server): ' + msg1 + '\n'

		msg1 = ''
		network_info = ''
		try:
			network_info = subprocess.check_output('service hostapd status'.split())
		except:
			pass
		for i in network_info.split('\n'):
			if 'running' in i: msg1 += 'running'
		if msg1 == '': msg1 += 'stopped'
		msg += 'hostapd (AP): ' + msg1 + '\n'

		msg1 = ''
		network_info = ''
		try:
			network_info = subprocess.check_output('service networking status'.split())
		except:
			pass
		for i in network_info.split('\n'):
			if 'SUCCESS' in i: msg1 += 'started'
		if msg1 == '': msg1 += 'stopped'
		msg += 'networking: ' + msg1 + '\n\n'

		msg1 = ''
		network_info = ''
		try:
			network_info = subprocess.check_output('ip addr show wlan0'.split())
		except:
			pass
		for i in network_info.split('\n'):
			if 'inet ' in i:
				if not '169.254' in i.split(' ')[5]: msg1 += i.split(' ')[5][0:-3] + ' ' + i[-5:] + '\n'
		network_info = ''
		try:
			network_info = subprocess.check_output('ip addr show wlan1'.split())
		except:
			pass
		for i in network_info.split('\n'):
			if 'inet ' in i:
				if not '169.254' in i.split(' ')[5]: msg1 += i.split(' ')[5][0:-3] + ' ' + i[-5:] + '\n'
		network_info = ''
		try:
			network_info = subprocess.check_output('ip addr show br0'.split())
		except:
			pass
		for i in network_info.split('\n'):
			if 'inet ' in i:

				if not '169.254' in i.split(' ')[5]:
					if 'br0:0' in i:
						msg1 += i.split(' ')[5][0:-3] + ' ' + i[-5:] + '\n'
					else:
						msg1 += i.split(' ')[5][0:-3] + ' ' + i[-3:] + '\n'
		msg += 'ip address\n' + msg1 + '\n'

		self.ShowMessage(msg)

	def on_wifi_default(self, e):
		self.ssid.SetValue('OpenPlotter')
		self.passw.SetValue('12345678')
		self.wifi_channel.SetValue('6')
		self.wifi_mode.SetValue('IEEE 802.11g')
		self.wifi_wpa.SetValue('WPA2')

	def enable_disable_wifi(self, s):
		if s == 1:
			self.wlan.Disable()
			self.passw.Disable()
			self.ssid.Disable()
			self.share.Disable()
			self.wlan_label.Disable()
			self.passw_label.Disable()
			self.ssid_label.Disable()
			self.share_label.Disable()
			self.wifi_settings_label.Disable()
			self.wifi_channel.Disable()
			self.wifi_channel_label.Disable()
			self.wifi_mode.Disable()
			self.wifi_mode_label.Disable()
			self.wifi_wpa.Disable()
			self.wifi_wpa_label.Disable()
			self.wifi_button_default.Disable()
			self.wifi_enable.SetValue(True)
			self.bridge_enable.Disable()
			self.conf.set('WIFI', 'enable', '1')
		else:
			self.wlan.Enable()
			self.passw.Enable()
			self.ssid.Enable()
			self.share.Enable()
			self.wlan_label.Enable()
			self.passw_label.Enable()
			self.ssid_label.Enable()
			self.share_label.Enable()
			self.wifi_settings_label.Enable()
			self.wifi_channel.Enable()
			self.wifi_channel_label.Enable()
			self.wifi_mode.Enable()
			self.wifi_mode_label.Enable()
			self.wifi_wpa.Enable()
			self.wifi_wpa_label.Enable()
			self.wifi_button_default.Enable()
			self.wifi_enable.SetValue(False)
			self.bridge_enable.Enable()
			self.conf.set('WIFI', 'enable', '0')

			###########################################	NMEA 0183 kplex

	def page_kplex(self):
		title = wx.StaticText(self.p_kplex, label=_(' KPLEX '))

		self.list_kplex = CheckListCtrl2(self.p_kplex, 152)
		self.list_kplex.InsertColumn(0, _('Name'), width=130)
		self.list_kplex.InsertColumn(1, _('Type'), width=45)
		self.list_kplex.InsertColumn(2, _('io'), width=45)
		self.list_kplex.InsertColumn(3, _('Port/Address'), width=95)
		self.list_kplex.InsertColumn(4, _('Bauds/Port'), width=60)
		self.list_kplex.InsertColumn(5, _('inFilter'), width=55)
		self.list_kplex.InsertColumn(6, _('Filtering'), width=80)
		self.list_kplex.InsertColumn(7, _('outFilter'), width=60)
		self.list_kplex.InsertColumn(8, _('Filtering'), width=80)
		self.list_kplex.Bind(wx.EVT_LIST_ITEM_ACTIVATED, self.edit_kplex)

		diagnostic = wx.Button(self.p_kplex, label=_('diagnostic'))
		diagnostic.Bind(wx.EVT_BUTTON, self.on_diagnostic_kplex)

		add = wx.Button(self.p_kplex, label=_('add'))
		add.Bind(wx.EVT_BUTTON, self.on_add_kplex)
		delete = wx.Button(self.p_kplex, label=_('delete'))
		delete.Bind(wx.EVT_BUTTON, self.on_delete_kplex)

		restart = wx.Button(self.p_kplex, label=_('Restart'))
		restart.Bind(wx.EVT_BUTTON, self.on_restart_kplex)
		advanced = wx.Button(self.p_kplex, label=_('Advanced'))
		advanced.Bind(wx.EVT_BUTTON, self.on_advanced_kplex)
		apply_changes = wx.Button(self.p_kplex, label=_('Apply changes'))
		apply_changes.Bind(wx.EVT_BUTTON, self.on_apply_changes_kplex)
		cancel_changes = wx.Button(self.p_kplex, label=_('Cancel changes'))
		cancel_changes.Bind(wx.EVT_BUTTON, self.on_cancel_changes_kplex)

		hlistbox = wx.BoxSizer(wx.HORIZONTAL)
		hlistbox.Add(self.list_kplex, 1, wx.ALL | wx.EXPAND, 5)

		hbox = wx.BoxSizer(wx.HORIZONTAL)
		hbox.Add((0, 0), 1, wx.RIGHT | wx.LEFT, 5)
		hbox.Add(add, 0, wx.RIGHT | wx.LEFT, 5)
		hbox.Add(delete, 0, wx.RIGHT | wx.LEFT, 5)

		hboxb = wx.BoxSizer(wx.HORIZONTAL)
		hboxb.Add(diagnostic, 0, wx.RIGHT | wx.LEFT, 5)
		hboxb.Add(restart, 0, wx.RIGHT | wx.LEFT, 5)
		hboxb.Add(advanced, 0, wx.RIGHT | wx.LEFT, 5)
		hboxb.Add((0, 0), 1, wx.RIGHT | wx.LEFT, 5)
		hboxb.Add(apply_changes, 0, wx.RIGHT | wx.LEFT, 5)
		hboxb.Add(cancel_changes, 0, wx.RIGHT | wx.LEFT, 5)

		vbox = wx.BoxSizer(wx.VERTICAL)
		vbox.Add(title, 0, wx.ALL | wx.EXPAND, 5)
		vbox.Add(hlistbox, 1, wx.ALL | wx.EXPAND, 0)
		vbox.Add(hbox, 0, wx.ALL | wx.EXPAND, 0)
		vbox.AddSpacer(5)
		vbox.Add(hboxb, 0, wx.ALL | wx.EXPAND, 0)

		self.p_kplex.SetSizer(vbox)

	def on_advanced_kplex(self, event):
		self.ShowMessage(_(
			'OpenPlotter will close. Add manual settings at the end of the configuration file. Open OpenPlotter again and restart multiplexer to apply changes.'))
		subprocess.Popen(['leafpad', home + '/.kplex.conf'])
		self.Close()

	def on_restart_kplex(self, event):
		self.ShowStatusBarRED(_('Closing Kplex'))
		subprocess.call(["pkill", '-9', "kplex"])
		subprocess.Popen('kplex')
		self.ShowStatusBarGREEN(_('Kplex restarted'))
		self.read_kplex_conf()

	def on_cancel_changes_kplex(self, event):
		self.read_kplex_conf()
		self.ShowStatusBarBLACK('')

	def edit_kplex(self, e):
		idx = e.GetIndex()

		if self.kplex[idx][1] == 'system' or self.kplex[idx][1] == 'opencpn' or self.kplex[idx][1] == 'signalk':
			self.ShowStatusBarRED(_('You can not edit this.'))
			return
		edit = []
		for i in range(9):
			edit.append(self.list_kplex.GetItem(idx, i).GetText())
		edit.append(idx)
		self.edit_add_kplex(edit)

	def on_add_kplex(self, e):
		self.edit_add_kplex(0)

	def edit_add_kplex(self, edit):
		dlg = addkplex(edit, self.kplex, self)
		dlg.ShowModal()
		result = dlg.result
		dlg.Destroy()

		if result != 0:
			k = int(result[11])
			if edit == 0:
				self.kplex.append(result)
				self.set_list_kplex()
			else:
				for i in range(10):
					self.kplex[k][i] = result[i]
				self.set_list_kplex()

	def read_kplex_conf(self):
		self.kplex = []
		try:
			file = open(self.home + '/.kplex.conf', 'r')
			data = file.readlines()
			file.close()

			l_tmp = [None] * 8
			self.manual_settings = ''
			for index, item in enumerate(data):

				if self.manual_settings:
					if item != '\n': self.manual_settings += item
				else:
					if re.search('\[*\]', item):
						if l_tmp[3] == 'in' or l_tmp[3] == 'out' or l_tmp[3] == 'both':
							self.kplex.append(l_tmp)
						l_tmp = [None] * 11
						l_tmp[6] = 'none'
						l_tmp[7] = 'nothing'
						l_tmp[8] = 'none'
						l_tmp[9] = 'nothing'
						if '[serial]' in item: l_tmp[2] = 'Serial'
						if '[tcp]' in item: l_tmp[2] = 'TCP'
						if '[udp]' in item: l_tmp[2] = 'UDP'
						if '#[' in item:
							l_tmp[10] = '0'
						else:
							l_tmp[10] = '1'
					if 'direction=in' in item:
						l_tmp[3] = 'in'
					if 'direction=out' in item:
						l_tmp[3] = 'out'
					if 'direction=both' in item:
						l_tmp[3] = 'both'
					if 'name=' in item and 'filename=' not in item:
						l_tmp[1] = self.extract_value(item)
					if 'address=' in item or 'filename=' in item:
						l_tmp[4] = self.extract_value(item)
						if '/dev' in l_tmp[4]: l_tmp[4] = l_tmp[4][5:]
					if 'port=' in item or 'baud=' in item:
						l_tmp[5] = self.extract_value(item)
					if 'ifilter=' in item and '-all' in item:
						l_tmp[6] = 'accept'
						l_tmp[7] = self.extract_value(item)
					if 'ifilter=' in item and '-all' not in item:
						l_tmp[6] = 'ignore'
						l_tmp[7] = self.extract_value(item)
					if 'ofilter=' in item and '-all' in item:
						l_tmp[8] = 'accept'
						l_tmp[9] = self.extract_value(item)
					if 'ofilter=' in item and '-all' not in item:
						l_tmp[8] = 'ignore'
						l_tmp[9] = self.extract_value(item)
					if '###Manual settings' in item:
						self.manual_settings = '###Manual settings\n\n'

			if l_tmp[3] == 'in' or l_tmp[3] == 'out' or l_tmp[3] == 'both':
				self.kplex.append(l_tmp)

			self.set_list_kplex()

		except IOError:
			self.ShowMessage(_('Multiplexer configuration file does not exist. Add inputs and apply changes.'))

	def extract_value(self, data):
		option, value = data.split('=')
		value = value.strip()
		return value

	def set_list_kplex(self):
		self.list_kplex.DeleteAllItems()
		index = 1
		for i in self.kplex:
			if i[1]:
				index = self.list_kplex.InsertStringItem(sys.maxint, i[1])

			if i[2]: self.list_kplex.SetStringItem(index, 1, i[2])
			if i[3]:
				self.list_kplex.SetStringItem(index, 2, i[3])
			else:
				self.list_kplex.SetStringItem(index, 2, '127.0.0.1')
			if i[4]: self.list_kplex.SetStringItem(index, 3, i[4])
			if i[5]: self.list_kplex.SetStringItem(index, 4, i[5])
			if i[6]:
				if i[6] == 'none': self.list_kplex.SetStringItem(index, 5, _('none'))
				if i[6] == 'accept': self.list_kplex.SetStringItem(index, 5, _('accept'))
				if i[6] == 'ignore': self.list_kplex.SetStringItem(index, 5, _('ignore'))
			if i[7] == 'nothing':
				self.list_kplex.SetStringItem(index, 6, _('nothing'))
			else:
				filters = i[7].replace(':-all', '')
				filters = filters.replace('+', '')
				filters = filters.replace('-', '')
				filters = filters.replace(':', ',')
				self.list_kplex.SetStringItem(index, 6, filters)
			if i[8]:
				if i[8] == 'none': self.list_kplex.SetStringItem(index, 7, _('none'))
				if i[8] == 'accept': self.list_kplex.SetStringItem(index, 7, _('accept'))
				if i[8] == 'ignore': self.list_kplex.SetStringItem(index, 7, _('ignore'))
			if i[9] == 'nothing':
				self.list_kplex.SetStringItem(index, 8, _('nothing'))
			else:
				filters = i[9].replace(':-all', '')
				filters = filters.replace('+', '')
				filters = filters.replace('-', '')
				filters = filters.replace(':', ',')
				self.list_kplex.SetStringItem(index, 8, filters)
			if i[10] == '1': self.list_kplex.CheckItem(index)

	def on_apply_changes_kplex(self, event):
		data = '# For advanced manual configuration, please visit: http://www.stripydog.com/kplex/configuration.html\n# Please do not modify defaults nor OpenPlotter GUI settings.\n# Add manual settings at the end of the document.\n\n'

		data += '###defaults\n\n'
		data += '[udp]\nname=system\ndirection=in\nport=10110\n\n'
		data += '[tcp]\nname=opencpn\ndirection=out\nmode=server\nofilter=-**RMB\nport=10109\n\n'
		data += '[udp]\nname=signalk\ndirection=out\nofilter=-OC***\naddress=127.0.0.1\nport=55556\n\n'
		data += '###end of defaults\n\n###OpenPlotter GUI settings\n\n'

		for index, item in enumerate(self.kplex):
			if not ('system' in item[1] or 'opencpn' in item[1] or 'signalk' in item[1]):
				if self.list_kplex.IsChecked(index):
					state = ''
				else:
					state = '#'

				if 'Serial' in item[2]:
					data += state + '[serial]\n' + state + 'name=' + item[1] + '\n' + state + 'direction=' + item[
						3] + '\n' + state + 'optional=yes\n'
					data += state + 'filename=/dev/' + item[4] + '\n' + state + 'baud=' + item[5] + '\n'
				if 'TCP' in item[2]:
					data += state + '[tcp]\n' + state + 'name=' + item[1] + '\n' + state + 'direction=' + item[
						3] + '\n' + state + 'optional=yes\n'
					if item[1] == 'gpsd': data += state + 'gpsd=yes\n'
					if item[3] == 'in':
						data += state + 'mode=client\n'
						data += state + 'persist=yes\n' + state + 'retry=10\n'
					else:
						data += state + 'mode=server\n'
					data += state + 'address=' + str(item[4]) + '\n' + state + 'port=' + str(item[5]) + '\n'
				if 'UDP' in item[2]:
					data += state + '[udp]\n' + state + 'name=' + item[1] + '\n' + state + 'direction=' + item[
						3] + '\n' + state + 'optional=yes\n'
					data += state + 'address=' + item[4] + '\n' + state + 'port=' + item[5] + '\n'

				if item[6] != 'none' and item[7] != 'nothing': data += state + 'ifilter=' + item[7] + '\n'
				if item[8] != 'none' and item[9] != 'nothing': data += state + 'ofilter=' + item[9] + '\n'
				data += '\n'

		data += '###end of OpenPlotter GUI settings\n\n'
		if self.manual_settings:
			data += self.manual_settings
		else:
			data += '###Manual settings\n\n'

		file = open(self.home + '/.kplex.conf', 'w')
		file.write(data)
		file.close()
		self.on_restart_kplex(0)
		self.read_kplex_conf()

	def on_delete_kplex(self, event):
		selected = self.list_kplex.GetFirstSelected()
		if selected == -1:
			self.ShowStatusBarRED(_('Select an item.'))
			return
		num = len(self.kplex)
		for i in range(num):
			if self.list_kplex.IsSelected(i):
				if self.kplex[i][1] == 'system' or self.kplex[i][1] == 'opencpn' or self.kplex[i][1] == 'signalk':
					self.ShowStatusBarRED(_('You can not delete this.'))
					return
				del self.kplex[i]
		self.set_list_kplex()

	''' TODO check unique name
	def process_name(self, r):
		list_tmp = []
		l = r.split(',')
		for item in l:
			item = item.strip()
			list_tmp.append(item)
		name = list_tmp[1]
		found = False
		for sublist in self.kplex:
			if sublist[1] == name:
				found = True
		for sublist in self.koutputs:
			if sublist[1] == name:
				found = True
		if found == True:
			self.GetStatusBar().SetForegroundColour(wx.RED)
			self.SetStatusText(_('Failed. This name already exists.'))
			return False
		else:
			return list_tmp
	'''

	def on_diagnostic_kplex(self, event):
		selected = self.list_kplex.GetFirstSelected()
		if selected == -1:
			self.ShowStatusBarRED(_('Select an item.'))
			return
		num = len(self.kplex)
		for i in range(num):
			if self.list_kplex.IsSelected(i):
				if self.list_kplex.IsChecked(i):
					file = open(self.home + '/.kplex.conf', 'r')
					data = file.read()
					file.close()

					if self.kplex[i][3] == 'in' or self.kplex[i][3] == 'both':
						data = data + '\n\n[tcp]\nname=system_debugi\ndirection=out\nofilter=+*****%' + self.kplex[i][
							1] + ':-all\nmode=server\nport=10112\n\n'
					if self.kplex[i][3] == 'out' or self.kplex[i][3] == 'both':
						data += '\n\n[tcp]\nname=system_debugo\ndirection=out\n'
						if self.kplex[i][8] != 'none' and self.kplex[i] != 'nothing': data += 'ofilter=' + \
																							  self.kplex[i][9] + '\n'
						data += 'mode=server\nport=10113\n\n'

					file = open(self.home + '/.debugkplex.conf', 'w')
					file.write(data)
					file.close()

					subprocess.call(["pkill", '-9', "kplex"])
					subprocess.Popen(['kplex', '-f', self.home + '/.debugkplex.conf'])
					time.sleep(0.5)
					subprocess.call(['pkill', '-f', 'diagnostic-NMEA.py'])
					if self.kplex[i][3] == 'in' or self.kplex[i][3] == 'both':
						subprocess.Popen(['python', self.currentpath + '/diagnostic-NMEA.py', '10112', 'diagnostic_input'])
					if self.kplex[i][3] == 'out' or self.kplex[i][3] == 'both':
						subprocess.Popen(['python', self.currentpath + '/diagnostic-NMEA.py', '10113', 'diagnostic_output'])

						###################################### I2C sensors

	def page_i2c(self):
		z0 = 20
		z1 = 45
		z2 = 75
		z3 = 105
		z4 = 145
		z5 = 175
		z6 = 215
		z7 = 245
		z8 = 290
		s1 = 20
		s2 = 130
		s3 = 560
		s4 = 300
		s5 = 500
		s6 = 220

		self.list_sk_path_temp = ['environment.inside.temperature', 'environment.outside.temperature']
		self.list_sk_path_hum = ['environment.inside.humidity', 'environment.outside.humidity']

		z = z0
		wx.StaticBox(self.p_i2c, label=_(' Settings '), size=(675, 325), pos=(5, 5))
		wx.StaticText(self.p_i2c, label=_('Sensors'), pos=(s2, z))
		wx.StaticText(self.p_i2c, label=_('Signal K'), pos=(s4, z))
		wx.StaticText(self.p_i2c, label=_('Offset'), pos=(s5, z))
		wx.StaticText(self.p_i2c, label=_('Rate (sec)'), pos=(s6, z))
		self.rate_list = ['0.1', '0.25', '0.5', '0.75', '1', '5', '30', '60', '300']
		z = z1
		self.heading_label = wx.StaticText(self.p_i2c, label=_('Heading'), pos=(s1, z))
		self.heading_sensor = wx.StaticText(self.p_i2c, pos=(s2, z))
		self.button_calibrate_imu = wx.Button(self.p_i2c, label=_('Calibrate'), pos=(s3, z))
		self.button_calibrate_imu.Bind(wx.EVT_BUTTON, self.on_i2c_calibrate_imu)
		wx.StaticText(self.p_i2c, label=_('navigation.headingMagnetic'), pos=(s4, z))
		self.heading_offset = wx.TextCtrl(self.p_i2c, size=(45, 20), pos=(s5, z))

		z = z2
		self.heel_label = wx.StaticText(self.p_i2c, label=_('Heel'), pos=(s1, z))
		self.heel_sensor = wx.StaticText(self.p_i2c, pos=(s2, z))
		wx.StaticText(self.p_i2c, label=_('navigation.attitude.roll'), pos=(s4, z))
		self.heel_offset = wx.TextCtrl(self.p_i2c, size=(45, 20), pos=(s5, z))
		self.rate_imu = wx.ComboBox(self.p_i2c, choices=self.rate_list, style=wx.CB_READONLY, size=(60, 25),
									pos=(s6, z - 5))
		z = z3
		self.pitch_label = wx.StaticText(self.p_i2c, label=_('Pitch'), pos=(s1, z))
		self.pitch_sensor = wx.StaticText(self.p_i2c, pos=(s2, z))
		button_reset_imu = wx.Button(self.p_i2c, label=_('Reset'), pos=(s3, z - 20))
		button_reset_imu.Bind(wx.EVT_BUTTON, self.on_reset_imu)
		wx.StaticText(self.p_i2c, label=_('navigation.attitude.pitch'), pos=(s4, z))
		self.pitch_offset = wx.TextCtrl(self.p_i2c, size=(45, 20), pos=(s5, z))
		z = z4
		self.pressure_label = wx.StaticText(self.p_i2c, label=_('Pressure'), pos=(s1, z))
		self.pressure_sensor = wx.StaticText(self.p_i2c, pos=(s2, z))
		button_reset_pressure = wx.Button(self.p_i2c, label=_('Reset'), pos=(s3, z + 5))
		button_reset_pressure.Bind(wx.EVT_BUTTON, self.on_reset_press)
		wx.StaticText(self.p_i2c, label=_('environment.outside.pressure'), pos=(s4, z))
		self.pressure_offset = wx.TextCtrl(self.p_i2c, size=(45, 20), pos=(s5, z))
		self.rate_press = wx.ComboBox(self.p_i2c, choices=self.rate_list, style=wx.CB_READONLY, size=(60, 25),
									  pos=(s6, z + 10))
		z = z5
		self.p_temp_label = wx.StaticText(self.p_i2c, label=_('Temperature'), pos=(s1, z))
		self.p_temp_sensor = wx.StaticText(self.p_i2c, pos=(s2, z))
		self.p_temp_skt = wx.ComboBox(self.p_i2c, choices=self.list_sk_path_temp, style=wx.CB_READONLY, size=(180, 25),
									  pos=(s4, z - 3))
		self.p_temp_offset = wx.TextCtrl(self.p_i2c, size=(45, 20), pos=(s5, z))
		z = z6
		self.humidity_label = wx.StaticText(self.p_i2c, label=_('Humidity'), pos=(s1, z))
		self.humidity_sensor = wx.StaticText(self.p_i2c, pos=(s2, z))
		button_reset_humidity = wx.Button(self.p_i2c, label=_('Reset'), pos=(s3, z + 5))
		button_reset_humidity.Bind(wx.EVT_BUTTON, self.on_reset_hum)
		self.humidity_skt = wx.ComboBox(self.p_i2c, choices=self.list_sk_path_hum, style=wx.CB_READONLY, size=(180, 25),
										pos=(s4, z - 3))
		self.humidity_offset = wx.TextCtrl(self.p_i2c, size=(45, 20), pos=(s5, z))
		self.rate_hum = wx.ComboBox(self.p_i2c, choices=self.rate_list, style=wx.CB_READONLY, size=(60, 25),
									pos=(s6, z + 10))
		z = z7
		self.h_temp_label = wx.StaticText(self.p_i2c, label=_('Temperature'), pos=(s1, z))
		self.h_temp_sensor = wx.StaticText(self.p_i2c, pos=(s2, z))
		self.h_temp_skt = wx.ComboBox(self.p_i2c, choices=self.list_sk_path_temp, style=wx.CB_READONLY, size=(180, 25),
									  pos=(s4, z - 3))
		self.h_temp_offset = wx.TextCtrl(self.p_i2c, size=(45, 20), pos=(s5, z))
		z = z8
		diagnostic = wx.Button(self.p_i2c, label=_('SK Diagnostic'), pos=(s1, z))
		diagnostic.Bind(wx.EVT_BUTTON, self.on_diagnostic_SK)

		cancel = wx.Button(self.p_i2c, label=_('cancel'), pos=(480, z))
		cancel.Bind(wx.EVT_BUTTON, self.on_i2c_cancel)
		apply = wx.Button(self.p_i2c, label=_('apply'), pos=(580, z))
		apply.Bind(wx.EVT_BUTTON, self.on_i2c_apply)

	def start_sensors(self):
		subprocess.Popen(['python', self.currentpath + '/i2c_d.py'], cwd=self.currentpath + '/imu')

	def stop_sensors(self):
		subprocess.call(['pkill', 'RTIMULibDemoGL'])
		subprocess.call(['pkill', '-f', 'i2c_d.py'])

	def read_i2c(self):
		self.imu_sensor = 'none'
		self.press_sensor = 'none'
		self.hum_sensor = 'none'
		self.check_sensors()

		self.rate_imu.SetValue(self.conf.get('I2C', 'rate_imu'))
		self.rate_press.SetValue(self.conf.get('I2C', 'rate_press'))
		self.rate_hum.SetValue(self.conf.get('I2C', 'rate_hum'))

		self.p_temp_skt.SetValue(self.conf.get('I2C', 'p_temp_skt'))
		self.h_temp_skt.SetValue(self.conf.get('I2C', 'h_temp_skt'))
		self.humidity_skt.SetValue(self.conf.get('I2C', 'hum_skt'))

		self.heading_offset.SetValue(self.conf.get('OFFSET', 'heading'))
		self.heel_offset.SetValue(self.conf.get('OFFSET', 'heel'))
		self.pitch_offset.SetValue(self.conf.get('OFFSET', 'pitch'))
		self.pressure_offset.SetValue(self.conf.get('OFFSET', 'pressure'))
		self.p_temp_offset.SetValue(self.conf.get('OFFSET', 'temperature_p'))
		self.humidity_offset.SetValue(self.conf.get('OFFSET', 'humidity'))
		self.h_temp_offset.SetValue(self.conf.get('OFFSET', 'temperature_h'))

	def check_sensors(self):
		detected = subprocess.check_output(['python', self.currentpath + '/imu/check_sensors.py'], cwd=self.currentpath + '/imu')
		l_detected = detected.split('\n')
		self.imu_sensor = l_detected[0]
		self.calibrated = l_detected[1]
		self.press_sensor = l_detected[2]
		self.hum_sensor = l_detected[3]

		if 'none' in self.imu_sensor:
			self.heading_label.Disable()
			self.heel_label.Disable()
			self.pitch_label.Disable()
			self.button_calibrate_imu.Disable()
			self.heading_sensor.SetLabel('')
			self.heel_sensor.SetLabel('')
			self.pitch_sensor.SetLabel('')
			self.conf.set('I2C', 'sk_hdg', '0')
			self.conf.set('I2C', 'sk_heel', '0')
			self.conf.set('I2C', 'sk_pitch', '0')
		else:
			self.heading_label.Enable()
			self.heel_label.Enable()
			self.pitch_label.Enable()
			if self.calibrated == '1':
				self.button_calibrate_imu.Disable()
			else:
				self.button_calibrate_imu.Enable()
			self.heading_sensor.SetLabel(self.imu_sensor)
			self.heel_sensor.SetLabel(self.imu_sensor)
			self.pitch_sensor.SetLabel(self.imu_sensor)
			self.conf.set('I2C', 'sk_hdg', '1')
			self.conf.set('I2C', 'sk_heel', '1')
			self.conf.set('I2C', 'sk_pitch', '1')

		if 'none' in self.press_sensor:
			self.pressure_label.Disable()
			self.p_temp_label.Disable()
			self.pressure_sensor.SetLabel('')
			self.p_temp_sensor.SetLabel('')
			self.conf.set('I2C', 'sk_press', '0')
			self.conf.set('I2C', 'sk_temp_p', '0')
		else:
			self.pressure_label.Enable()
			self.p_temp_label.Enable()
			self.pressure_sensor.SetLabel(self.press_sensor)
			self.p_temp_sensor.SetLabel(self.press_sensor)
			self.conf.set('I2C', 'sk_press', '1')
			self.conf.set('I2C', 'sk_temp_p', '1')

		if 'none' in self.hum_sensor:
			self.humidity_label.Disable()
			self.h_temp_label.Disable()
			self.humidity_sensor.SetLabel('')
			self.h_temp_sensor.SetLabel('')
			self.conf.set('I2C', 'sk_hum', '0')
			self.conf.set('I2C', 'sk_temp_h', '0')
		else:
			self.humidity_label.Enable()
			self.h_temp_label.Enable()
			self.humidity_sensor.SetLabel(self.hum_sensor)
			self.h_temp_sensor.SetLabel(self.hum_sensor)
			self.conf.set('I2C', 'sk_hum', '1')
			self.conf.set('I2C', 'sk_temp_h', '1')

	def on_i2c_apply(self, e):
		self.conf.set('I2C', 'rate_imu', str(self.rate_imu.GetValue()))
		self.conf.set('I2C', 'rate_press', str(self.rate_press.GetValue()))
		self.conf.set('I2C', 'rate_hum', str(self.rate_hum.GetValue()))

		self.conf.set('I2C', 'p_temp_skt', str(self.p_temp_skt.GetValue()))
		self.conf.set('I2C', 'h_temp_skt', str(self.h_temp_skt.GetValue()))
		self.conf.set('I2C', 'hum_skt', str(self.humidity_skt.GetValue()))

		try:
			self.conf.set('OFFSET', 'heading', str(float(self.heading_offset.GetValue())))
			self.conf.set('OFFSET', 'heel', str(float(self.heel_offset.GetValue())))
			self.conf.set('OFFSET', 'pitch', str(float(self.pitch_offset.GetValue())))
			self.conf.set('OFFSET', 'pressure', str(float(self.pressure_offset.GetValue())))
			self.conf.set('OFFSET', 'temperature_p', str(float(self.p_temp_offset.GetValue())))
			self.conf.set('OFFSET', 'humidity', str(float(self.humidity_offset.GetValue())))
			self.conf.set('OFFSET', 'temperature_h', str(float(self.h_temp_offset.GetValue())))
		except:
			self.ShowStatusBarRED(_("An offset is not a number"))
			self.read_i2c()

		self.restart_SK(0)

	def on_i2c_cancel(self, e):
		self.read_i2c()

	def on_i2c_calibrate_imu(self, e):
		self.stop_sensors()
		subprocess.Popen('RTIMULibDemoGL', cwd=self.currentpath + '/imu')
		msg = _('After calibrating, click apply.')
		self.ShowMessage(msg)

	def on_reset_imu(self, e):
		try:
			os.remove(self.currentpath + '/imu/RTIMULib.ini')
		except Exception, e:
			print str(e)
		self.button_calibrate_imu.Enable()
		self.heading_sensor.SetLabel('')
		self.heel_sensor.SetLabel('')
		self.pitch_sensor.SetLabel('')
		self.check_sensors()
		self.restart_SK(0)

	def on_reset_press(self, e):
		try:
			os.remove(self.currentpath + '/imu/RTIMULib2.ini')
		except Exception, e:
			print str(e)
		self.pressure_sensor.SetLabel('')
		self.p_temp_sensor.SetLabel('')
		self.check_sensors()
		self.restart_SK(0)

	def on_reset_hum(self, e):
		try:
			os.remove(self.currentpath + '/imu/RTIMULib3.ini')
		except Exception, e:
			print str(e)
		self.humidity_sensor.SetLabel('')
		self.h_temp_sensor.SetLabel('')
		self.check_sensors()
		self.restart_SK(0)

	###################################### SPI
	def page_spi(self):
		title = wx.StaticText(self.p_spi, label=_(' SPI MCP3008 '))

		self.list_MCP = wx.ListCtrl(self.p_spi, -1, style=wx.LC_REPORT | wx.SUNKEN_BORDER)
		self.list_MCP.InsertColumn(0, _('aktiv'), width=40)
		self.list_MCP.InsertColumn(1, _('channel'), width=65)
		self.list_MCP.InsertColumn(2, _('SK name'), width=310)
		self.list_MCP.InsertColumn(3, _('*'), width=120)
		self.list_MCP.InsertColumn(4, _('convert'), width=55)
		self.list_MCP.Bind(wx.EVT_LIST_ITEM_ACTIVATED, self.on_edit_MCP)

		restart = wx.Button(self.p_spi, label=_('restart'))
		restart.Bind(wx.EVT_BUTTON, self.on_restart_MCP)

		value_setting = wx.Button(self.p_spi, label=_('value setting'))
		value_setting.Bind(wx.EVT_BUTTON, self.on_value_setting)

		hlistbox = wx.BoxSizer(wx.HORIZONTAL)
		hlistbox.Add(self.list_MCP, 1, wx.ALL | wx.EXPAND, 5)

		hbox = wx.BoxSizer(wx.HORIZONTAL)
		hbox.Add(restart, 0, wx.RIGHT | wx.LEFT, 5)
		hbox.Add(value_setting, 0, wx.RIGHT | wx.LEFT, 5)

		vbox = wx.BoxSizer(wx.VERTICAL)
		vbox.Add(title, 0, wx.ALL | wx.EXPAND, 5)
		vbox.Add(hlistbox, 1, wx.ALL | wx.EXPAND, 0)
		vbox.Add(hbox, 0, wx.ALL, 0)

		self.p_spi.SetSizer(vbox)

	def read_MCP(self):
		self.MCP = []
		self.list_MCP.DeleteAllItems()
		data = self.conf.get('SPI', 'mcp')
		try:
			temp_list = eval(data)
		except:
			temp_list = []
		for ii in temp_list:
			self.MCP.append(ii)
			if '.*.' in ii[2]:
				SKkey2 = ii[2].replace('*', ii[3])
			else:
				SKkey2 = ii[2]
			self.list_MCP.Append([str(ii[0]), str(ii[1]), SKkey2, ii[3], ii[4]])

	def on_restart_MCP(self, e):
		self.restart_SK(0)

	def on_value_setting(self, e):
		edit = self.list_MCP.GetFirstSelected()
		if edit == -1:
			return
		dlg = addvaluesetting(edit, self)
		dlg.ShowModal()

		if self.MCP[edit][4] == 1:
			convert = 1
			self.conf.read()
			data = self.conf.get('SPI', 'value_' + str(edit))
			try:
				temp_list = eval(data)
			except:
				temp_list = []
			min = 1023
			max = 0
			for ii in temp_list:
				if ii[0] > max: max = ii[0]
				if ii[0] < min: min = ii[0]
			if min > 0:
				wx.MessageBox(_('minimum raw value in setting table > 0'), 'info', wx.OK | wx.ICON_INFORMATION)
				convert = 0
			if max < 1023:
				wx.MessageBox(_('maximum raw value in setting table < 1023'), 'info', wx.OK | wx.ICON_INFORMATION)
				convert = 0
			if convert == 0:
				self.MCP[edit][4] = convert
				self.conf.set('SPI', 'mcp', str(self.MCP))
				self.read_MCP()
				wx.MessageBox(_('convert disabled'), 'info', wx.OK | wx.ICON_INFORMATION)

	def on_edit_MCP(self, e):
		selected_MCP = e.GetIndex()
		edit = [selected_MCP, self.MCP[selected_MCP][0], self.MCP[selected_MCP][1], self.MCP[selected_MCP][2],
				self.MCP[selected_MCP][3], self.MCP[selected_MCP][4]]

		dlg = addMCP(edit, self)
		res = dlg.ShowModal()
		if res == wx.ID_OK:
			aktiv = dlg.aktiv.GetValue()
			convert = dlg.convert.GetValue()
			SKkey = dlg.SKkey.GetValue().encode('utf8')
			asterix = dlg.asterix.GetValue().encode('utf8')
			if aktiv and not SKkey:
				self.ShowStatusBarRED(_('Failed. Provide name and Signal K values.'))
				dlg.Destroy()
				return
			if '*' in SKkey:
				if not re.match('^[0-9a-zA-Z]+$', asterix):
					self.ShowStatusBarRED(_('Failed. The name must contain only letters and numbers.'))
					dlg.Destroy()
					return
				SKkey2 = SKkey.replace('*', asterix)
			else:
				SKkey2 = SKkey

			if aktiv:
				aktiv = 1
			else:
				aktiv = 0
			if convert:
				convert = 1
			else:
				convert = 0
			self.list_MCP.SetStringItem(edit[0], 0, str(aktiv))
			self.list_MCP.SetStringItem(edit[0], 2, SKkey2)
			self.list_MCP.SetStringItem(edit[0], 3, asterix)
			self.list_MCP.SetStringItem(edit[0], 4, str(convert))
			self.MCP[edit[0]][0] = aktiv
			self.MCP[edit[0]][2] = SKkey
			self.MCP[edit[0]][3] = asterix
			self.MCP[edit[0]][4] = convert
			self.conf.set('SPI', 'mcp', str(self.MCP))
		dlg.Destroy()
		self.conf.read()

	###################################### GPIO
	def page_gpio(self):
		title = wx.StaticText(self.p_gpio, label=_(' Sensors '))

		self.list_gpio = wx.ListCtrl(self.p_gpio, -1, style=wx.LC_REPORT | wx.SUNKEN_BORDER)
		self.list_gpio.InsertColumn(0, _('Name'), width=345)
		self.list_gpio.InsertColumn(1, _('I/O'), width=80)
		self.list_gpio.InsertColumn(2, 'GPIO', width=60)
		self.list_gpio.InsertColumn(3, 'Pull', width=80)
		self.list_gpio.Bind(wx.EVT_LIST_ITEM_ACTIVATED, self.edit_gpio)

		add = wx.Button(self.p_gpio, label=_('add'))
		add.Bind(wx.EVT_BUTTON, self.on_add_gpio)

		delete = wx.Button(self.p_gpio, label=_('delete'))
		delete.Bind(wx.EVT_BUTTON, self.on_delete_gpio)

		diagnostic = wx.Button(self.p_gpio, label=_('SK Diagnostic'))
		diagnostic.Bind(wx.EVT_BUTTON, self.on_diagnostic_SK)

		hlistbox_but = wx.BoxSizer(wx.VERTICAL)
		hlistbox_but.Add(add, 0, wx.ALL, 5)
		hlistbox_but.Add(delete, 0, wx.ALL, 5)

		hlistbox = wx.BoxSizer(wx.HORIZONTAL)
		hlistbox.Add(self.list_gpio, 1, wx.ALL | wx.EXPAND, 5)
		hlistbox.Add(hlistbox_but, 0, wx.RIGHT | wx.LEFT, 0)

		vbox = wx.BoxSizer(wx.VERTICAL)
		vbox.Add(title, 0, wx.ALL | wx.EXPAND, 5)
		vbox.Add(hlistbox, 1, wx.ALL | wx.EXPAND, 0)
		vbox.Add(diagnostic, 0, wx.RIGHT | wx.LEFT, 5)

		self.p_gpio.SetSizer(vbox)

	def read_gpio(self):
		self.gpio = []
		self.list_gpio.DeleteAllItems()
		data = self.conf.get('GPIO', 'sensors')
		try:
			temp_list = eval(data)
		except:
			temp_list = []
		for ii in temp_list:
			self.gpio.append(ii)
			# name, io, GPIO, pull
			if ii[1] == 'out':
				io = _('output')
			else:
				io = _('input')
			self.list_gpio.Append([ii[0], io, ii[2], ii[3]])

	def edit_gpio(self, e):
		selected_gpio = e.GetIndex()
		edit = [selected_gpio, self.gpio[selected_gpio][0], self.gpio[selected_gpio][1], self.gpio[selected_gpio][2],
				self.gpio[selected_gpio][3]]
		self.edit_add_gpio(edit)

	def on_add_gpio(self, e):
		self.edit_add_gpio(0)

	def edit_add_gpio(self, edit):
		selected_gpio = 0
		if edit != 0: selected_gpio = edit[3]
		avalaible_gpio = ['5', '6', '12', '13', '16', '17', '18', '19', '20', '21', '22', '23', '24', '25', '26', '27']
		tmp_list1 = []
		tmp_list2 = []
		for i in self.gpio:
			tmp_list1.append(i[2])
		for i in avalaible_gpio:
			if i not in tmp_list1 or i == selected_gpio: tmp_list2.append(i)
		avalaible_gpio = tmp_list2
		dlg = addGPIO(avalaible_gpio, edit)
		res = dlg.ShowModal()
		if res == wx.ID_OK:
			name = dlg.name.GetValue()
			name = name.encode('utf8')
			io_selection = dlg.io_select.GetValue()
			io_selection = io_selection.encode('utf8')
			if io_selection == _('output'):
				io = 'out'
			else:
				io = 'in'
			if io == 'out':
				dlg2 = wx.MessageDialog(None, _(
					'CAUTION. If you connect a closed switch or some inappropriate circuit, you could short out and damage your board when this output becomes "High". Are you sure to enable this output?'),
										_('Question'), wx.YES_NO | wx.NO_DEFAULT | wx.ICON_EXCLAMATION)
				if dlg2.ShowModal() == wx.ID_YES:
					dlg2.Destroy()
				else:
					dlg2.Destroy()
					dlg.Destroy()
					return
			gpio_selection = dlg.gpio_select.GetValue()
			gpio_selection = gpio_selection.encode('utf8')
			pull_selection = dlg.pull_select.GetValue()
			pull_selection = pull_selection.encode('utf8')
			if not name or not io_selection or not gpio_selection or (not pull_selection and io == 'in'):
				self.ShowMessage(_('Failed. You must fill in all fields.'))
				dlg.Destroy()
				return
			if not re.match('^[0-9a-zA-Z]+$', name):
				self.ShowMessage(_('Failed. The name must contain only letters and numbers.'))
				dlg.Destroy()
				return
			if edit == 0:
				self.list_gpio.Append([name, io_selection, gpio_selection, pull_selection])
				self.gpio.append([name, io, gpio_selection, pull_selection])
			else:
				self.list_gpio.SetStringItem(edit[0], 0, name)
				self.list_gpio.SetStringItem(edit[0], 1, io_selection)
				self.list_gpio.SetStringItem(edit[0], 2, gpio_selection)
				self.list_gpio.SetStringItem(edit[0], 3, pull_selection)
				self.gpio[edit[0]][0] = name
				self.gpio[edit[0]][1] = io
				self.gpio[edit[0]][2] = gpio_selection
				self.gpio[edit[0]][3] = pull_selection
			self.apply_changes_gpio()
		dlg.Destroy()

	def on_delete_gpio(self, e):
		selected_gpio = self.list_gpio.GetFirstSelected()
		if selected_gpio == -1:
			self.ShowStatusBarBLACK(_('Select an item to delete.'))
			return
		del self.gpio[selected_gpio]
		self.list_gpio.DeleteItem(selected_gpio)
		self.apply_changes_gpio()

	def apply_changes_gpio(self):
		self.conf.set('GPIO', 'sensors', str(self.gpio))
		self.restart_SK(0)

	####################### Accounts
	def page_account(self):
		wx.StaticBox(self.p_account, label=_(' Twitter '), size=(330, 205), pos=(10, 10))
		self.twitter_enable = wx.CheckBox(self.p_account, label=_('Enable'), pos=(20, 32))
		self.twitter_enable.Bind(wx.EVT_CHECKBOX, self.on_twitter_enable)

		wx.StaticText(self.p_account, label=_('apiKey'), pos=(20, 70))
		self.apiKey = wx.TextCtrl(self.p_account, -1, size=(180, 32), pos=(150, 65))
		wx.StaticText(self.p_account, label=_('apiSecret'), pos=(20, 105))
		self.apiSecret = wx.TextCtrl(self.p_account, -1, size=(180, 32), pos=(150, 100))
		wx.StaticText(self.p_account, label=_('accessToken'), pos=(20, 140))
		self.accessToken = wx.TextCtrl(self.p_account, -1, size=(180, 32), pos=(150, 135))
		wx.StaticText(self.p_account, label=_('accessTokenSecret'), pos=(20, 175))
		self.accessTokenSecret = wx.TextCtrl(self.p_account, -1, size=(180, 32), pos=(150, 170))

		wx.StaticBox(self.p_account, label=_(' Gmail '), size=(330, 205), pos=(350, 10))
		self.gmail_enable = wx.CheckBox(self.p_account, label=_('Enable'), pos=(360, 32))
		self.gmail_enable.Bind(wx.EVT_CHECKBOX, self.on_gmail_enable)
		wx.StaticText(self.p_account, label=_('Gmail account'), pos=(360, 70))
		self.Gmail_account = wx.TextCtrl(self.p_account, -1, size=(180, 32), pos=(490, 65))
		wx.StaticText(self.p_account, label=_('Gmail password'), pos=(360, 105))
		self.Gmail_password = wx.TextCtrl(self.p_account, -1, size=(180, 32), pos=(490, 100))
		wx.StaticText(self.p_account, label=_('Recipient'), pos=(360, 140))
		self.Recipient = wx.TextCtrl(self.p_account, -1, size=(180, 32), pos=(490, 135))

	def read_account(self):
		if self.conf.get('TWITTER', 'apiKey'): self.apiKey.SetValue('********************')
		if self.conf.get('TWITTER', 'apiSecret'): self.apiSecret.SetValue('********************')
		if self.conf.get('TWITTER', 'accessToken'): self.accessToken.SetValue('********************')
		if self.conf.get('TWITTER', 'accessTokenSecret'): self.accessTokenSecret.SetValue('********************')
		if self.conf.get('TWITTER', 'enable') == '1':
			self.twitter_enable.SetValue(True)
			self.apiKey.Disable()
			self.apiSecret.Disable()
			self.accessToken.Disable()
			self.accessTokenSecret.Disable()

		if self.conf.get('GMAIL', 'gmail'): self.Gmail_account.SetValue(self.conf.get('GMAIL', 'gmail'))
		if self.conf.get('GMAIL', 'password'): self.Gmail_password.SetValue('********************')
		if self.conf.get('GMAIL', 'recipient'): self.Recipient.SetValue(self.conf.get('GMAIL', 'recipient'))
		if self.conf.get('GMAIL', 'enable') == '1':
			self.gmail_enable.SetValue(True)
			self.Gmail_account.Disable()
			self.Gmail_password.Disable()
			self.Recipient.Disable()	

	def on_twitter_enable(self, e):
		if not self.apiKey.GetValue() or not self.apiSecret.GetValue() or not self.accessToken.GetValue() or not self.accessTokenSecret.GetValue():
			self.twitter_enable.SetValue(False)
			self.ShowStatusBarRED(_('Enter valid Twitter apiKey, apiSecret, accessToken and accessTokenSecret.'))
			return
		if self.twitter_enable.GetValue():
			self.apiKey.Disable()
			self.apiSecret.Disable()
			self.accessToken.Disable()
			self.accessTokenSecret.Disable()
			self.conf.set('TWITTER', 'enable', '1')
			if not '*****' in self.apiKey.GetValue():
				self.conf.set('TWITTER', 'apiKey', self.apiKey.GetValue())
				self.apiKey.SetValue('********************')
			if not '*****' in self.apiSecret.GetValue():
				self.conf.set('TWITTER', 'apiSecret', self.apiSecret.GetValue())
				self.apiSecret.SetValue('********************')
			if not '*****' in self.accessToken.GetValue():
				self.conf.set('TWITTER', 'accessToken', self.accessToken.GetValue())
				self.accessToken.SetValue('********************')
			if not '*****' in self.accessTokenSecret.GetValue():
				self.conf.set('TWITTER', 'accessTokenSecret', self.accessTokenSecret.GetValue())
				self.accessTokenSecret.SetValue('********************')
		else:
			self.conf.set('TWITTER', 'enable', '0')
			self.apiKey.Enable()
			self.apiSecret.Enable()
			self.accessToken.Enable()
			self.accessTokenSecret.Enable()
		self.restart_SK(0)

	def on_gmail_enable(self, e):
		if not self.Gmail_account.GetValue() or not self.Gmail_password.GetValue() or not self.Recipient.GetValue():
			self.gmail_enable.SetValue(False)
			self.ShowStatusBarRED(_('Enter valid Gmail account, Gmail password and Recipient.'))
			return
		if self.gmail_enable.GetValue():
			self.Gmail_account.Disable()
			self.Gmail_password.Disable()
			self.Recipient.Disable()
			self.conf.set('GMAIL', 'enable', '1')
			self.conf.set('GMAIL', 'gmail', self.Gmail_account.GetValue())
			if not '*****' in self.Gmail_password.GetValue():
				self.conf.set('GMAIL', 'password', self.Gmail_password.GetValue())
				self.Gmail_password.SetValue('********************')
			self.conf.set('GMAIL', 'recipient', self.Recipient.GetValue())
		else:
			self.conf.set('GMAIL', 'enable', '0')
			self.Gmail_account.Enable()
			self.Gmail_password.Enable()
			self.Recipient.Enable()
		self.restart_SK(0)

	####################### Actions
	def page_action(self):
		title = wx.StaticText(self.p_action, label=_(' Triggers '))

		self.list_triggers = CheckListCtrl(self.p_action, 100)
		self.list_triggers.InsertColumn(0, _('trigger'), width=400)
		self.list_triggers.InsertColumn(1, _('operator'), width=100)
		self.list_triggers.InsertColumn(2, _('value'))
		self.list_triggers.Bind(wx.EVT_LIST_ITEM_SELECTED, self.on_print_actions)
		self.list_triggers.Bind(wx.EVT_LIST_ITEM_ACTIVATED, self.on_edit_triggers)
		self.list_triggers.SetMinSize((10, 10))

		add_trigger = wx.Button(self.p_action, label=_('add'))
		add_trigger.Bind(wx.EVT_BUTTON, self.on_add_trigger)

		delete_trigger = wx.Button(self.p_action, label=_('delete'))
		delete_trigger.Bind(wx.EVT_BUTTON, self.on_delete_trigger)

		self.list_actions = wx.ListCtrl(self.p_action, style=wx.LC_REPORT | wx.SUNKEN_BORDER)
		self.list_actions.InsertColumn(0, _('action'), width=200)
		self.list_actions.InsertColumn(1, _('data'), width=220)
		self.list_actions.InsertColumn(2, _('repeat'), width=130)
		self.list_actions.Bind(wx.EVT_LIST_ITEM_ACTIVATED, self.edit_actions)
		self.list_actions.SetMinSize((10, 10))

		add_action = wx.Button(self.p_action, label=_('add'))
		add_action.Bind(wx.EVT_BUTTON, self.on_add_action)

		delete_action = wx.Button(self.p_action, label=_('delete'))
		delete_action.Bind(wx.EVT_BUTTON, self.on_delete_action)

		stop_all = wx.Button(self.p_action, label=_('Stop all'))
		stop_all.Bind(wx.EVT_BUTTON, self.on_stop_actions)

		start_all = wx.Button(self.p_action, label=_('Start all'))
		start_all.Bind(wx.EVT_BUTTON, self.on_start_actions)

		apply_changes = wx.Button(self.p_action, label=_('Apply changes'))
		apply_changes.Bind(wx.EVT_BUTTON, self.on_apply_changes_actions)
		cancel_changes = wx.Button(self.p_action, label=_('Cancel changes'))
		cancel_changes.Bind(wx.EVT_BUTTON, self.on_cancel_changes_actions)

		hlistbox_but = wx.BoxSizer(wx.VERTICAL)
		hlistbox_but.Add(add_trigger, 0, wx.ALL, 5)
		hlistbox_but.Add(delete_trigger, 0, wx.ALL, 5)

		hlistbox = wx.BoxSizer(wx.HORIZONTAL)
		hlistbox.Add(self.list_triggers, 1, wx.ALL | wx.EXPAND, 5)
		hlistbox.Add(hlistbox_but, 0, wx.RIGHT | wx.LEFT, 0)

		hlistbox_butb10 = wx.BoxSizer(wx.VERTICAL)
		hlistbox_butb10.Add(add_action, 0, wx.ALL, 5)
		hlistbox_butb10.Add(delete_action, 0, wx.ALL, 5)

		hlistboxb = wx.BoxSizer(wx.HORIZONTAL)
		hlistboxb.Add(self.list_actions, 1, wx.ALL | wx.EXPAND, 5)
		hlistboxb.Add(hlistbox_butb10, 0, wx.RIGHT | wx.LEFT, 0)

		hbox = wx.BoxSizer(wx.HORIZONTAL)
		hbox.Add(stop_all, 0, wx.RIGHT | wx.LEFT, 5)
		hbox.Add(start_all, 0, wx.RIGHT | wx.LEFT, 5)
		hbox.Add((0, 0), 1, wx.RIGHT | wx.LEFT, 5)
		hbox.Add(apply_changes, 0, wx.RIGHT | wx.LEFT, 5)
		hbox.Add(cancel_changes, 0, wx.RIGHT | wx.LEFT, 5)

		vbox = wx.BoxSizer(wx.VERTICAL)
		vbox.Add(title, 0, wx.ALL | wx.EXPAND, 5)
		vbox.Add(hlistbox, 1, wx.ALL | wx.EXPAND, 0)
		vbox.Add(hlistboxb, 1, wx.ALL | wx.EXPAND, 0)
		vbox.Add(hbox, 0, wx.ALL | wx.EXPAND, 0)

		self.p_action.SetSizer(vbox)

	def read_triggers(self):
		self.operators_list = [_('was not updated in the last (sec.)'), _('was updated in the last (sec.)'), '=',
							   '<', '<=', '>', '>=', _('is on'), _('is off'), _('contains')]

		self.triggers = []
		self.list_triggers.DeleteAllItems()
		data = self.conf.get('ACTIONS', 'triggers')
		try:
			temp_list = eval(data)
		except:
			temp_list = []
		for ii in temp_list:
			self.triggers.append(ii)
			if ii[1] == -1: 
				sk = _('Always')
				op = ''
			else: 
				sk = ii[1]
				op = self.operators_list[ii[2]]
			self.list_triggers.Append([sk, op, ii[3]])
			if ii[0] == 1:
				last = self.list_triggers.GetItemCount() - 1
				self.list_triggers.CheckItem(last)

	def on_print_actions(self, e):
		self.actions = Actions(self)
		selected_trigger = e.GetIndex()
		self.list_actions.DeleteAllItems()
		for i in self.triggers[selected_trigger][4]:
			if i[3] == 0.0:
				repeat = ''
			else:
				repeat = str(i[2])
			time_units = self.actions.time_units[i[3]]
			repeat2 = repeat + ' ' + time_units
			self.list_actions.Append(
				[self.actions.options[self.actions.getOptionsListIndex(i[0])][0].decode('utf8'), i[1].decode('utf8'),
				 repeat2.decode('utf8')])

	def on_edit_triggers(self, e):
		t = e.GetIndex()
		SKkey = self.triggers[t][1]
		operator = self.triggers[t][2]
		value = self.triggers[t][3]
		edit = [t, SKkey, operator, value]
		self.edit_add_trigger(edit)

	def on_add_trigger(self, e):
		self.edit_add_trigger(0)

	def edit_add_trigger(self, edit):
		dlg = addTrigger(self, edit)
		res = dlg.ShowModal()
		if res == wx.ID_OK:
			if dlg.always.GetValue():
				SKkey0 = _('Always')
				SKkey = -1
				operator0 = ''
				operator = ''
				value0 = ''
				value = ''
			else:
				group=dlg.skgroups.GetValue()
				signalk=dlg.signalk.GetValue()
				SKkey = group+'.'+signalk
				SKkey = SKkey.encode('utf8')
				SKkey0 = SKkey.decode('utf8')
				operator0 = dlg.operator.GetValue()
				operator0 = operator0.decode('utf8')
				operator = None
				c = 0
				for i in self.operators_list:
					if operator0 == i: operator = c
					c = c + 1
				value = dlg.value.GetValue()
				value = value.encode('utf8')
				value0 = value.decode('utf8')
				if '--' in SKkey :
					self.ShowMessage(_('Failed. Select group and key.'))
					dlg.Destroy()
					return
				if operator == None :
					self.ShowMessage(_('Failed. Select operator.'))
					dlg.Destroy()
					return
				if operator == 7 or operator == 8:
					operator0='='
					operator == 2
					if operator == 7: value = '1'
					if operator == 8: value = '0'
				if not value :
					self.ShowMessage(_('Failed. Enter value.'))
					dlg.Destroy()
					return
			if edit == 0:
				self.list_triggers.Append([SKkey0, operator0, value0])
				tmp = [1, SKkey, operator, value, []]
				self.triggers.append(tmp)
				total = self.list_triggers.GetItemCount()
				for x in xrange(0, total, 1):
					self.list_triggers.Select(x, on=0)
				self.list_triggers.Select(total - 1, on=1)
				self.list_triggers.CheckItem(total - 1)
			else:
				self.list_triggers.SetStringItem(edit[0], 0, SKkey0)
				self.list_triggers.SetStringItem(edit[0], 1, operator0)
				self.list_triggers.SetStringItem(edit[0], 2, value0)
				self.triggers[edit[0]][1] = SKkey
				self.triggers[edit[0]][2] = operator
				self.triggers[edit[0]][3] = value
		dlg.Destroy()

	def edit_actions(self, e):
		self.actions = Actions(self)
		a = e.GetIndex()
		t = self.list_triggers.GetFirstSelected()
		action = self.actions.getOptionsListIndex(self.triggers[t][4][a][0])
		data = self.triggers[t][4][a][1]
		repeat = self.triggers[t][4][a][2]
		unit = self.triggers[t][4][a][3]
		edit = [a, action, data, repeat, unit]
		self.edit_add_action(edit)

	def on_add_action(self, e):
		self.edit_add_action(0)

	def edit_add_action(self, edit):
		self.actions = Actions(self)
		selected_trigger_position = self.list_triggers.GetFirstSelected()
		if selected_trigger_position == -1:
			self.ShowStatusBarBLACK(_('Select a trigger to add actions.'))
			return
		dlg = addAction(self, self.actions.options, self.actions.time_units, edit)
		res = dlg.ShowModal()
		if res == wx.ID_OK:
			action_selection = dlg.action_select.GetCurrentSelection()
			if action_selection == -1:
				self.ShowMessage(_('Failed. Select an action.'))
				dlg.Destroy()
				return
			if dlg.repeat.GetValue():
				repeat = dlg.repeat.GetValue()
			else:
				repeat = '0'
			try:
				repeat = float(repeat)
			except:
				self.ShowMessage(_('Failed. "Repeat after" must be a number.'))
				dlg.Destroy()
				return
			action = self.actions.options[action_selection][0]
			data0 = dlg.data.GetValue()
			data = data0.encode('utf8')
			time_units_selection = dlg.repeat_unit.GetCurrentSelection()
			time_units = self.actions.time_units[time_units_selection]
			if repeat == 0.0:
				repeat2 = time_units
			else:
				repeat2 = str(repeat) + ' ' + time_units
			if edit == 0:
				self.list_actions.Append([action.decode('utf8'), data.decode('utf8'), repeat2.decode('utf8')])
				tmp = []
				tmp.append(self.actions.options[action_selection][3])
				tmp.append(data)
				tmp.append(repeat)
				tmp.append(time_units_selection)
				self.triggers[selected_trigger_position][4].append(tmp)
			else:
				self.list_actions.SetStringItem(edit[0], 0, action.decode('utf8'))
				self.list_actions.SetStringItem(edit[0], 1, data.decode('utf8'))
				self.list_actions.SetStringItem(edit[0], 2, repeat2.decode('utf8'))
				self.triggers[selected_trigger_position][4][edit[0]][0] = self.actions.options[action_selection][3]
				self.triggers[selected_trigger_position][4][edit[0]][1] = data
				self.triggers[selected_trigger_position][4][edit[0]][2] = repeat
				self.triggers[selected_trigger_position][4][edit[0]][3] = time_units_selection
		dlg.Destroy()

	def on_delete_trigger(self, e):
		selected = self.list_triggers.GetFirstSelected()
		if selected == -1:
			self.ShowStatusBarBLACK(_('Select an item to delete.'))
		else:
			del self.triggers[selected]
			self.list_triggers.DeleteItem(selected)
			self.list_actions.DeleteAllItems()

	def on_delete_action(self, e):
		selected_trigger = self.list_triggers.GetFirstSelected()
		selected_action = self.list_actions.GetFirstSelected()
		if selected_action == -1:
			self.ShowStatusBarBLACK(_('Select an item to delete.'))
		else:
			del self.triggers[selected_trigger][4][selected_action]
			self.list_actions.DeleteItem(selected_action)

	def on_apply_changes_actions(self, e):
		i = 0
		for ii in self.triggers:
			if self.list_triggers.IsChecked(i):
				self.triggers[i][0] = 1
			else:
				self.triggers[i][0] = 0
			i += 1
		self.conf.set('ACTIONS', 'triggers', str(self.triggers))
		self.restart_SK(0)

	def on_cancel_changes_actions(self, e):
		self.read_triggers()
		self.ShowStatusBarBLACK(_('Actions changes cancelled'))

	def on_stop_actions(self, e):
		subprocess.call(['python', self.currentpath + '/ctrl_actions.py', '0'])
		self.ShowStatusBarBLACK(_('Actions stopped'))
		self.conf.read()
		self.read_triggers()
		self.list_actions.DeleteAllItems()

	def on_start_actions(self, e):
		subprocess.call(['python', self.currentpath + '/ctrl_actions.py', '1'])
		self.ShowStatusBarBLACK(_('Actions started'))
		self.conf.read()
		self.read_triggers()
		self.list_actions.DeleteAllItems()

	####################### 1W sensors
	def page_1w(self):
		title = wx.StaticText(self.p_1w, label=_(' Temperature sensors '))

		self.list_DS18B20 = wx.ListCtrl(self.p_1w, style=wx.LC_REPORT)
		self.list_DS18B20.InsertColumn(0, _('Name'), width=100)
		self.list_DS18B20.InsertColumn(1, _('Signal K'), width=310)
		self.list_DS18B20.InsertColumn(2, _('ID'), width=105)
		self.list_DS18B20.InsertColumn(4, _('Offset'), width=50)
		self.list_DS18B20.Bind(wx.EVT_LIST_ITEM_ACTIVATED, self.edit_DS18B20)

		add = wx.Button(self.p_1w, label=_('add'))
		add.Bind(wx.EVT_BUTTON, self.on_add_DS18B20)

		delete = wx.Button(self.p_1w, label=_('delete'))
		delete.Bind(wx.EVT_BUTTON, self.on_delete_DS18B20)

		diagnostic = wx.Button(self.p_1w, label=_('SK Diagnostic'))
		diagnostic.Bind(wx.EVT_BUTTON, self.on_diagnostic_SK)

		hlistbox_but = wx.BoxSizer(wx.VERTICAL)
		hlistbox_but.Add(add, 0, wx.ALL, 5)
		hlistbox_but.Add(delete, 0, wx.ALL, 5)

		hlistbox = wx.BoxSizer(wx.HORIZONTAL)
		hlistbox.Add(self.list_DS18B20, 1, wx.ALL | wx.EXPAND, 5)
		hlistbox.Add(hlistbox_but, 0, wx.RIGHT | wx.LEFT, 0)

		vbox = wx.BoxSizer(wx.VERTICAL)
		vbox.Add(title, 0, wx.ALL | wx.EXPAND, 5)
		vbox.Add(hlistbox, 1, wx.ALL | wx.EXPAND, 0)
		vbox.Add(diagnostic, 0, wx.RIGHT | wx.LEFT, 5)

		self.p_1w.SetSizer(vbox)

	def start_1w(self):
		subprocess.Popen(['python', self.currentpath + '/1w_d.py'])

	def stop_1w(self):
		subprocess.call(['pkill', '-f', '1w_d.py'])

	def read_DS18B20(self):
		self.DS18B20 = []
		self.list_DS18B20.DeleteAllItems()
		data = self.conf.get('1W', 'DS18B20')
		try:
			temp_list = eval(data)
		except:
			temp_list = []
		for ii in temp_list:
			self.DS18B20.append(ii)
			if '.*.' in ii[1]:
				SKkey2 = ii[1].replace('*', ii[0])
			else:
				SKkey2 = ii[1]
			self.list_DS18B20.Append([ii[0], SKkey2, ii[2], ii[3]])

	def edit_DS18B20(self, e):
		selected_DS18B20 = e.GetIndex()
		edit = [selected_DS18B20, self.DS18B20[selected_DS18B20][0], self.DS18B20[selected_DS18B20][1],
				self.DS18B20[selected_DS18B20][2], self.DS18B20[selected_DS18B20][3]]
		self.edit_add_DS18B20(edit)

	def on_add_DS18B20(self, e):
		self.edit_add_DS18B20(0)

	def edit_add_DS18B20(self, edit):
		dlg = addDS18B20(edit, self)
		res = dlg.ShowModal()
		if res == wx.ID_OK:
			name = dlg.name.GetValue()
			name = name.encode('utf8')
			SKkey = dlg.SKkey.GetValue()
			SKkey = SKkey.encode('utf8')
			sensor_id = dlg.id_select.GetValue()
			sensor_id = sensor_id.encode('utf8')
			offset = dlg.offset.GetValue()
			offset = offset.encode('utf8')
			if not name or not SKkey:
				self.ShowMessage(_('Failed. Provide name and Signal K values.'))
				dlg.Destroy()
				return
			if not re.match('^[0-9a-zA-Z]+$', name):
				self.ShowMessage(_('Failed. The name must contain only letters and numbers.'))
				dlg.Destroy()
				return
			if '.*.' in SKkey:
				SKkey2 = SKkey.replace('*', name)
			else:
				SKkey2 = SKkey
			if sensor_id == '':
				self.ShowMessage(_('Failed. Select sensor ID.'))
				dlg.Destroy()
				return
			try:
				float(offset)
			except:
				offset = '0.0'
			if edit == 0:
				self.list_DS18B20.Append([name, SKkey2, sensor_id, offset])
				self.DS18B20.append([name, SKkey, sensor_id, offset])
			else:
				self.list_DS18B20.SetStringItem(edit[0], 0, name)
				self.list_DS18B20.SetStringItem(edit[0], 1, SKkey2)
				self.list_DS18B20.SetStringItem(edit[0], 2, sensor_id)
				self.list_DS18B20.SetStringItem(edit[0], 3, offset)
				self.DS18B20[edit[0]][0] = name
				self.DS18B20[edit[0]][1] = SKkey
				self.DS18B20[edit[0]][2] = sensor_id
				self.DS18B20[edit[0]][3] = offset
			self.apply_changes_DS18B20()
		dlg.Destroy()

	def on_delete_DS18B20(self, e):
		selected_DS18B20 = self.list_DS18B20.GetFirstSelected()
		if selected_DS18B20 == -1:
			self.ShowStatusBarBLACK(_('Select an item to delete.'))
			return
		del self.DS18B20[selected_DS18B20]
		self.list_DS18B20.DeleteItem(selected_DS18B20)
		self.apply_changes_DS18B20()

	def apply_changes_DS18B20(self):
		self.conf.set('1W', 'DS18B20', str(self.DS18B20))
		self.restart_SK(0)

	####################### USB manager
	def page_usb(self):
		title = wx.StaticText(self.p_usb, label=_(' USB Serial ports '))

		self.list_USBinst = wx.ListCtrl(self.p_usb, -1, style=wx.LC_REPORT | wx.SUNKEN_BORDER)
		self.list_USBinst.InsertColumn(0, _('name'), width=130)
		self.list_USBinst.InsertColumn(1, _('vendor'), width=55)
		self.list_USBinst.InsertColumn(2, _('product'), width=60)
		self.list_USBinst.InsertColumn(3, _('port'), width=90)
		self.list_USBinst.InsertColumn(4, _('serial'), width=130)
		self.list_USBinst.InsertColumn(5, _('remember'), width=100)
		self.list_USBinst.Bind(wx.EVT_LIST_ITEM_ACTIVATED, self.edit_USBinst)

		add = wx.Button(self.p_usb, label=_('add'))
		add.Bind(wx.EVT_BUTTON, self.on_add_USBinst)

		delete = wx.Button(self.p_usb, label=_('delete'))
		delete.Bind(wx.EVT_BUTTON, self.on_delete_USBinst)

		hlistbox = wx.BoxSizer(wx.HORIZONTAL)
		hlistbox.Add(self.list_USBinst, 1, wx.ALL | wx.EXPAND, 5)

		hbox = wx.BoxSizer(wx.HORIZONTAL)
		hbox.Add(add, 0, wx.RIGHT | wx.LEFT, 5)
		hbox.Add(delete, 0, wx.RIGHT | wx.LEFT, 5)

		vbox = wx.BoxSizer(wx.VERTICAL)
		vbox.Add(title, 0, wx.ALL | wx.EXPAND, 5)
		vbox.Add(hlistbox, 1, wx.ALL | wx.EXPAND, 0)
		vbox.Add(hbox, 0, wx.ALL | wx.EXPAND, 0)

		self.p_usb.SetSizer(vbox)

	def start_udev(self):
		subprocess.call(['sudo', 'udevadm', 'control', '--reload-rules'])
		subprocess.call(['sudo', 'udevadm', 'trigger', '--attr-match=subsystem=tty'])

	def read_USBinst(self):
		self.USBinst = []
		self.list_USBinst.DeleteAllItems()
		data = self.conf.get('UDEV', 'USBinst')
		sentence = 0
		try:
			temp_list = eval(data)
		except:
			temp_list = []
		for ii in temp_list:
			self.USBinst.append(ii)
			self.list_USBinst.Append(
				[ii[0].decode('utf8'), ii[1].decode('utf8'), ii[2].decode('utf8'), ii[4].decode('utf8'),
				 ii[3].decode('utf8'), ii[5]])
			sentence = 1
		try:
			filesize = os.stat('/etc/udev/rules.d/10-openplotter.rules').st_size
		except:
			filesize = 0

		if sentence == 0 and filesize > 10:
			self.apply_changes_USBinst()
		if sentence == 1 and filesize < 10:
			self.apply_changes_USBinst()

	def edit_USBinst(self, e):
		selected_USBinst = e.GetIndex()
		edit = [selected_USBinst, self.USBinst[selected_USBinst][0], self.USBinst[selected_USBinst][1],
				self.USBinst[selected_USBinst][2], self.USBinst[selected_USBinst][3], self.USBinst[selected_USBinst][4],
				self.USBinst[selected_USBinst][5], self.USBinst[selected_USBinst][6]]
		self.edit_add_USBinst(edit)

	def on_add_USBinst(self, e):
		self.edit_add_USBinst(0)

	def edit_add_USBinst(self, edit):
		dlg = addUSBinst(edit,self)
		res = dlg.ShowModal()
		if res == wx.ID_OK:
			OPname_selection = dlg.OPname_select.GetValue()
			if not re.match('^[0-9a-zA-Z]{1,8}$', OPname_selection):
				self.ShowMessage(_('Failed. The new name must be a string between 1 and 8 letters and/or numbers.'))
				dlg.Destroy()
				return
			OPname_selection = 'ttyOP_' + OPname_selection
			OPname_selection = OPname_selection.encode('utf8')
			vendor = dlg.vendor
			vendor = vendor.encode('utf8')
			product = dlg.product
			product = product.encode('utf8')
			serial = dlg.serial
			serial = serial.encode('utf8')
			con_port = dlg.con_port
			con_port = con_port.encode('utf8')
			device = dlg.device
			device = device.encode('utf8')
			rem = dlg.rem
			if edit == 0:
				self.list_USBinst.Append(
					[OPname_selection.decode('utf8'), vendor.decode('utf8'), product.decode('utf8'),
					 con_port.decode('utf8'), serial.decode('utf8'), rem])
				self.USBinst.append([OPname_selection, vendor, product, serial, con_port, rem, device])
			else:
				self.list_USBinst.SetStringItem(edit[0], 0, OPname_selection.decode('utf8'))
				self.list_USBinst.SetStringItem(edit[0], 1, vendor.decode('utf8'))
				self.list_USBinst.SetStringItem(edit[0], 2, product.decode('utf8'))
				self.list_USBinst.SetStringItem(edit[0], 3, con_port.decode('utf8'))
				self.list_USBinst.SetStringItem(edit[0], 4, serial.decode('utf8'))
				# self.list_USBinst.SetStringItem(edit[0],5,device.decode('utf8'))
				self.list_USBinst.SetStringItem(edit[0], 5, rem)
				self.USBinst[edit[0]][0] = OPname_selection
				self.USBinst[edit[0]][1] = vendor
				self.USBinst[edit[0]][2] = product
				self.USBinst[edit[0]][3] = serial
				self.USBinst[edit[0]][4] = con_port
				self.USBinst[edit[0]][5] = rem
				self.USBinst[edit[0]][6] = device
			self.apply_changes_USBinst()
		dlg.Destroy()

	def on_delete_USBinst(self, e):
		selected_USBinst = self.list_USBinst.GetFirstSelected()
		if selected_USBinst == -1:
			self.ShowStatusBarBLACK(_('Select an item to delete.'))
			return
		del self.USBinst[selected_USBinst]
		self.list_USBinst.DeleteItem(selected_USBinst)
		self.apply_changes_USBinst()

	def apply_changes_USBinst(self):
		self.conf.set('UDEV', 'USBinst', str(self.USBinst))
		file = open('10-openplotter.rules', 'w')
		for i in self.USBinst:
			index = self.USBinst.index(i)
			if self.USBinst[index][5] == 'port':
				write_str = 'KERNEL=="' + self.USBinst[index][6] + '*", KERNELS=="' + self.USBinst[index][4]
				write_str = write_str + '" ,SYMLINK+="' + self.USBinst[index][0] + '"\n'
			else:
				if self.USBinst[index][3] == '':
					write_str = 'SUBSYSTEM=="tty", ATTRS{idVendor}=="' + self.USBinst[index][1]
					write_str = write_str + '",ATTRS{idProduct}=="' + self.USBinst[index][2]
					write_str = write_str + '" ,SYMLINK+="' + self.USBinst[index][0] + '"\n'
				else:
					write_str = 'SUBSYSTEM=="tty", ATTRS{idVendor}=="' + self.USBinst[index][1]
					write_str = write_str + '",ATTRS{idProduct}=="' + self.USBinst[index][2]
					write_str = write_str + '",ATTRS{serial}=="' + self.USBinst[index][3]
					write_str = write_str + '" ,SYMLINK+="' + self.USBinst[index][0] + '"\n'

			file.write(write_str)
		file.close()
		test = 0
		test = os.system('sudo mv 10-openplotter.rules /etc/udev/rules.d')
		print test
		self.ShowStatusBarRED(_('Restarting ...'))
		self.start_udev()
		time.sleep(1.5)
		self.ShowStatusBarGREEN(_('USB names added and restarted'))
		self.SerialCheck()

	###################################### N2K
	def page_n2k(self):
		wx.StaticBox(self.p_n2k, label=_(' Settings '), size=(230, 265), pos=(10, 10))
		i = 35
		self.CANUSB_label = wx.StaticText(self.p_n2k, label=_('CAN-USB-CAN device'), pos=(20, i))
		self.SerDevLs = []
		i += 20
		self.can_usb = wx.ComboBox(self.p_n2k, choices=self.SerDevLs, style=wx.CB_READONLY, size=(140, 32), pos=(20, i))
		self.can_usb.Bind(wx.EVT_COMBOBOX, self.on_n2k_device)
		i += 35
		self.n2k_enable = wx.CheckBox(self.p_n2k, label=_('Enable N2K input'), pos=(20, i))
		self.n2k_enable.Bind(wx.EVT_CHECKBOX, self.on_n2k_enable)
		i += 25
		self.N2K_diagnostic_b = wx.Button(self.p_n2k, label=_('Diagnostic input'), pos=(20, i))
		self.N2K_diagnostic_b.Bind(wx.EVT_BUTTON, self.on_N2K_diagnostic)
		i += 35
		self.n2k_out_enable = wx.CheckBox(self.p_n2k, label=_('Enable N2K output'), pos=(20, i))
		self.n2k_out_enable.Bind(wx.EVT_CHECKBOX, self.on_n2k_output)
		i += 25
		self.N2K_diagnostic_out_b = wx.Button(self.p_n2k, label=_('Diagnostic output'), pos=(20, i))
		self.N2K_diagnostic_out_b.Bind(wx.EVT_BUTTON, self.on_N2K_diagnostic_out)
		i += 40
		self.button_N2K_setting = wx.Button(self.p_n2k, label=_('Output settings'), pos=(20, i))
		self.button_N2K_setting.Bind(wx.EVT_BUTTON, self.on_N2K_setting)

		wx.StaticBox(self.p_n2k, label=_(' Inputs '), size=(430, 50), pos=(250, 10))
		self.n2kinputs_label = wx.StaticText(self.p_n2k, label=_('PGNs: All'), pos=(260, 30))

		wx.StaticBox(self.p_n2k, label=_(' Outputs '), size=(430, 210), pos=(250, 65))
		wx.StaticText(self.p_n2k, label='PGNs:', pos=(260, 85))
		self.n2koutputs_label = wx.StaticText(self.p_n2k, pos=(260, 105))

	def read_n2k(self):
		self.mmsi.SetValue(self.vessel_self.mmsi)
		self.set_label_SK()
		if self.conf.get('N2K', 'enable') == '1':
			self.n2k_enable.SetValue(True)
			self.can_usb.Disable()
			self.button_N2K_setting.Disable()
			self.N2K_diagnostic_b.Disable()
		self.n2koutputs_label.SetLabel(self.conf.get('N2K', 'pgn_output'))
		if self.conf.get('N2K', 'output') == '1':
			self.n2k_out_enable.SetValue(True)
			self.N2K_diagnostic_out_b.Disable()
		self.can_usb.SetValue(self.conf.get('N2K', 'can_usb'))

	def on_n2k_device(self, e):
		self.conf.set('N2K', 'can_usb', self.can_usb.GetValue())

	def on_n2k_enable(self, e):
		with open(self.home + '/.config/signalk-server-node/settings/openplotter-settings.json') as data_file:
			data = json.load(data_file)
		isChecked = self.n2k_enable.GetValue()
		if isChecked:
			if not self.can_usb.GetValue():
				self.n2k_enable.SetValue(False)
				self.ShowStatusBarBLACK(_('You have to select a CAN-USB-CAN device'))
				return
			subprocess.call(['pkill', '-f', 'CAN-USB-stick.py'])
			self.conf.set('N2K', 'enable', '1')
			self.conf.set('N2K', 'can_usb', self.can_usb.GetValue())
			self.can_usb.Disable()
			self.button_N2K_setting.Disable()
			self.N2K_diagnostic_b.Disable()
			exist = 0
			ii = 0
			for i in data['pipedProviders']:
				if i['id'] == 'CAN-USB':
					# edit nmea 2000
					data['pipedProviders'][ii]['pipeElements'][0]['options'][
						'command'] = 'actisense-serial ' + self.can_usb.GetValue()
					exist = 1
				ii += 1
			if exist == 0:
				new = {"id": "CAN-USB",
					   "pipeElements": [{"type": "providers/execute", "options": {"command": "actisense-serial xxx"}},
										{"type": "providers/liner"}, {"type": "providers/n2kAnalyzer"},
										{"type": "providers/n2k-signalk"}]}
				new['pipeElements'][0]['options']['command'] = 'actisense-serial ' + self.can_usb.GetValue()
				data['pipedProviders'].append(new)
		else:
			self.conf.set('N2K', 'enable', '0')
			self.can_usb.Enable()
			self.button_N2K_setting.Enable()
			self.N2K_diagnostic_b.Enable()
			ii = 0
			for i in data['pipedProviders']:
				if i['id'] == 'CAN-USB':
					# delete nmea 2000
					del data['pipedProviders'][ii]
				ii += 1
		self.n2koutputs_label.SetLabel(self.conf.get('N2K', 'pgn_output'))
		self.set_label_SK()
		with open(self.home + '/.config/signalk-server-node/settings/openplotter-settings.json', 'w') as outfile:
			json.dump(data, outfile)
		self.restart_SK(0)

	def on_n2k_output(self, e):
		isChecked = self.n2k_out_enable.GetValue()
		if isChecked:
			if not self.can_usb.GetValue():
				self.n2k_out_enable.SetValue(False)
				self.ShowStatusBarBLACK(_('You have to select a CAN-USB-CAN device'))
				return
			self.N2K_diagnostic_out_b.Disable()
			self.conf.set('N2K', 'output', '1')
			subprocess.call(['pkill', '-f', 'diagnostic-N2K-output.py'])
			subprocess.call(['pkill', '-f', 'N2K-server_d.py'])
			subprocess.Popen(['python', self.currentpath + '/N2K-server_d.py'])
		else:
			self.conf.set('N2K', 'output', '0')
			subprocess.call(['pkill', '-f', 'N2K-server_d.py'])
			self.N2K_diagnostic_out_b.Enable()

	def on_N2K_setting(self, e):
		tty = str(self.can_usb.GetValue())
		if len(tty) == 0:
			self.ShowStatusBarBLACK(_('You have to select a CAN-USB-CAN device'))
			return
		subprocess.call(['pkill', '-f', 'CAN-USB-stick.py'])
		self.stop_sensors()
		self.stop_1w()
		subprocess.Popen(['python', self.currentpath + '/CAN-USB-stick.py'])
		self.ShowStatusBarBLACK(_('Select PGNs to transmit and enable N2K input/output again.'))

	def on_N2K_diagnostic(self, e):
		tty = str(self.can_usb.GetValue())
		if len(tty) == 0:
			self.ShowStatusBarBLACK(_('You have to select a CAN-USB-CAN device'))
			return
		subprocess.call(['pkill', '-f', 'diagnostic-N2K-input.py'])
		subprocess.Popen(['python', self.currentpath + '/diagnostic-N2K-input.py'])
		self.ShowStatusBarBLACK(_('Show received PGNs.'))

	def on_N2K_diagnostic_out(self, e):
		tty = str(self.can_usb.GetValue())
		if len(tty) == 0:
			self.ShowStatusBarBLACK(_('You have to select a CAN-USB-CAN device'))
			return
		subprocess.call(['pkill', '-f', 'diagnostic-N2K-output.py'])
		subprocess.Popen(['python', self.currentpath + '/diagnostic-N2K-output.py'])
		self.ShowStatusBarBLACK(_('Show sent PGNs.'))

	###################################### Signal K
	def page_sk(self):
		wx.StaticBox(self.p_sk, label=_(' Settings '), size=(230, 265), pos=(10, 10))

		self.mmsi = wx.TextCtrl(self.p_sk, -1, size=(110, 32), pos=(20, 65))
		self.mmsi_label = wx.StaticText(self.p_sk, label='MMSI', pos=(140, 70))

		self.button_restartSK = wx.Button(self.p_sk, label=_('Restart'), pos=(20, 115))
		self.button_restartSK.Bind(wx.EVT_BUTTON, self.restart_SK)

		diagnostic = wx.Button(self.p_sk, label=_('Diagnostic'), pos=(20, 165))
		diagnostic.Bind(wx.EVT_BUTTON, self.on_diagnostic_SK)

		apply_changes = wx.Button(self.p_sk, label=_('Apply changes'), pos=(125, 115))
		apply_changes.Bind(wx.EVT_BUTTON, self.apply_SK)

		wx.StaticBox(self.p_sk, label=_(' Inputs '), size=(430, 140), pos=(250, 10))
		self.SKinputs_label = wx.StaticText(self.p_sk, label='NMEA 0183: system_output - UDP localhost 55556',
											pos=(260, 30))
		try:
			response = requests.get('http://localhost:3000/signalk')
		except:
			self.restart_SK(0x0000)
		response = requests.get('http://localhost:3000/signalk')
		data = response.json()
		text = _('Version: ')
		text += data['endpoints']['v1']['version']
		text += '\n\nhttp: '
		text += data['endpoints']['v1']['signalk-http']
		text += '\nws: '
		text += data['endpoints']['v1']['signalk-ws']
		text += '\nNMEA 0183: TCP localhost 10111'
		wx.StaticBox(self.p_sk, label=_(' Outputs '), size=(430, 120), pos=(250, 155))
		wx.StaticText(self.p_sk, label=text, pos=(260, 175))

		show_SK = wx.Button(self.p_sk, label=_('Show Web Socket'), pos=(250, 285))
		show_SK.Bind(wx.EVT_BUTTON, self.show_SK)

		tools_SK = wx.Button(self.p_sk, label=_('Show Signal K tools'), pos=(420, 285))
		tools_SK.Bind(wx.EVT_BUTTON, self.show_tools_SK)

	def show_SK(self, e):
		url = 'http://localhost:3000/examples/consumer-example.html'
		webbrowser.open(url, new=2)

	def show_tools_SK(self, e):
		url = 'http://localhost:3000'
		webbrowser.open(url, new=2)

	def restart_SK(self, e):
		# stopping sk server
		self.ShowStatusBarRED(_('Closing Signal K server ...'))
		self.vessel_self = ''
		subprocess.call(["pkill", '-9', "node"])
		while self.util_process_exist("node"):
			time.sleep(0.01)
		# restarting sk server and providers
		self.vessel_self = checkVesselSelf()
		self.ShowStatusBarGREEN(_('Signal K server restarted'))

	def on_diagnostic_SK(self, e):
		subprocess.call(['pkill', '-f', 'diagnostic-SK-input.py'])
		subprocess.Popen(['python', self.currentpath + '/diagnostic-SK-input.py'])

	def apply_SK(self, e):
		mmsi = self.mmsi.GetValue()
		uuid = "urn:mrn:imo:mmsi:" + mmsi
		if uuid == '':
			self.ShowStatusBarRED(_('You have to provide a MMSI.'))
			return
		with open(self.home + '/.config/signalk-server-node/settings/openplotter-settings.json') as data_file:
			data = json.load(data_file)
		data['vessel']['mmsi'] = mmsi
		data['vessel']['uuid'] = uuid
		with open(self.home + '/.config/signalk-server-node/settings/openplotter-settings.json', 'w') as outfile:
			json.dump(data, outfile)
		self.restart_SK(0)

	def set_label_SK(self):
		text = 'kplex output: UDP 55556 (NMEA 0183)\n'
		text += 'OP-sensors: UDP 55557 (I2C-, 1W-, SPI-sensors)\n'
		text += 'notifications: UDP 55558 (status of GPIO for switches, MQTT,\n'
		text += '     messages, SMS messages, opencpn alarm messages)\n'
		text += 'serial: UDP 55559 (any sensor connected to USB/UART)\n'
		text += 'wifi: UDP 55561 (any sensor connected by wifi, ex. esp8266)\n'
		if self.conf.get('N2K', 'enable') == '1':
			text += 'NMEA 2K: CAN-USB-CAN - ' + self.conf.get('N2K', 'can_usb')
		self.SKinputs_label.SetLabel(text)

	####################### SMS
	def page_sms(self):
		wx.StaticBox(self.p_sms, label=_(' Settings '), size=(330, 180), pos=(10, 10))
		self.sms_enable = wx.CheckBox(self.p_sms, label=_('Enable settings'), pos=(20, 30))
		self.sms_enable.Bind(wx.EVT_CHECKBOX, self.onsms_enable)

		self.sms_dev_label = wx.StaticText(self.p_sms, label='Serial port', pos=(20, 60))
		self.sms_dev = wx.ComboBox(self.p_sms, choices=self.SerDevLs, style=wx.CB_READONLY, size=(150, 32),
								   pos=(20, 80))
		sms_con_list = ['at', 'at19200', 'at115200', 'blueat', 'bluephonet', 'bluefbus', 'blueobex', 'bluerfgnapbus',
						'bluerfat', 'blues60', 'dlr3', 'dku2', 'dku2at', 'dku2phonet', 'dku5', 'dku5fbus', 'fbus',
						'fbusdlr3', 'fbusdku5', 'fbusblue', 'fbuspl2303', 'irdaphonet', 'irdaat', 'irdaobex',
						'irdagnapbus', 'phonetblue', 'proxyphonet', 'proxyfbus', 'proxyat', 'proxyobex', 'proxygnapbus',
						'proxys60', 'mbus']

		self.sms_bt_label = wx.StaticText(self.p_sms, label=_('Bluetooth address'), pos=(180, 60))
		self.sms_bt = wx.TextCtrl(self.p_sms, -1, size=(150, 32), pos=(180, 80))

		self.sms_con_label = wx.StaticText(self.p_sms, label='Connection', pos=(20, 120))
		self.sms_con = wx.ComboBox(self.p_sms, choices=sms_con_list, style=wx.CB_READONLY, size=(150, 32),
								   pos=(20, 140))

		self.button_sms_identify = wx.Button(self.p_sms, label=_('Identify'), pos=(180, 140))
		self.button_sms_identify.Bind(wx.EVT_BUTTON, self.on_sms_identify)

		wx.StaticBox(self.p_sms, label=_(' Sending '), size=(330, 180), pos=(350, 10))

		self.sms_enable_send = wx.CheckBox(self.p_sms, label=_('Enable sending SMS'), pos=(360, 30))
		self.sms_enable_send.Bind(wx.EVT_CHECKBOX, self.onsms_enable_send)

		self.phone_number_label = wx.StaticText(self.p_sms, label=_('Send to phone'), pos=(360, 60))
		self.phone_number = wx.TextCtrl(self.p_sms, -1, size=(150, 32), pos=(360, 80))

		self.sms_text_label = wx.StaticText(self.p_sms, label=_('Text'), pos=(360, 120))
		self.sms_text = wx.TextCtrl(self.p_sms, -1, size=(150, 32), pos=(360, 140))

		self.button_sms_test = wx.Button(self.p_sms, label=_('Test'), pos=(520, 140))
		self.button_sms_test.Bind(wx.EVT_BUTTON, self.on_sms_test)

	def read_sms(self):
		if self.conf.get('SMS', 'serial') == '0':
			self.sms_dev.SetValue(self.SerDevLs[0])
		else:
			self.sms_dev.SetValue(self.conf.get('SMS', 'serial'))
		self.sms_bt.SetValue(self.conf.get('SMS', 'bluetooth'))
		self.sms_con.SetValue(self.conf.get('SMS', 'connection'))
		if self.conf.get('SMS', 'enable') == '1':
			self.sms_enable.SetValue(True)
			self.sms_dev_label.Disable()
			self.sms_dev.Disable()
			self.sms_bt_label.Disable()
			self.sms_bt.Disable()
			self.sms_con_label.Disable()
			self.sms_con.Disable()
		else:
			self.button_sms_identify.Disable()

		self.phone_number.SetValue(self.conf.get('SMS', 'phone'))
		if self.conf.get('SMS', 'enable_sending') == '1':
			self.sms_enable_send.SetValue(True)
			self.phone_number_label.Disable()
			self.phone_number.Disable()
		else:
			self.button_sms_test.Disable()
			self.sms_text.Disable()
			self.sms_text_label.Disable()

	def save_gammu_settings(self, port, con):
		gammu_conf = ConfigParser.SafeConfigParser()
		gammu_conf.read(self.home + '/.gammurc')
		gammu_conf.set('gammu', 'port', port)
		gammu_conf.set('gammu', 'connection', con)
		with open(self.home + '/.gammurc', 'wb') as configfile:
			gammu_conf.write(configfile)

	def onsms_enable(self, e):
		isChecked = self.sms_enable.GetValue()
		if isChecked:
			if self.sms_dev.GetValue() == _('none'):
				if self.sms_bt.GetValue() == '':
					self.ShowStatusBarRED(_('You have to provide a serial port or a bluetooth address.'))
					self.sms_enable.SetValue(False)
					return
				else:
					bluetooth = self.sms_bt.GetValue()
			else:
				bluetooth = ''
				self.sms_bt.SetValue(bluetooth)
				serial = self.sms_dev.GetValue()
			if self.sms_con.GetValue() == '':
				self.ShowStatusBarRED(_('You have to provide a connection type.'))
				self.sms_enable.SetValue(False)
				return
			else:
				connection = self.sms_con.GetValue()
			self.conf.set('SMS', 'enable', '1')
			if self.sms_dev.GetValue() == _('none'):
				self.conf.set('SMS', 'serial', '0')
				port = bluetooth
			else:
				self.conf.set('SMS', 'serial', serial)
				port = serial
			self.conf.set('SMS', 'bluetooth', bluetooth)
			self.conf.set('SMS', 'connection', connection)
			self.sms_dev_label.Disable()
			self.sms_dev.Disable()
			self.sms_bt_label.Disable()
			self.sms_bt.Disable()
			self.sms_con_label.Disable()
			self.sms_con.Disable()
			self.button_sms_identify.Enable()
			self.save_gammu_settings(port, connection)
		else:
			self.conf.set('SMS', 'enable', '0')
			self.sms_dev_label.Enable()
			self.sms_dev.Enable()
			self.sms_bt_label.Enable()
			self.sms_bt.Enable()
			self.sms_con_label.Enable()
			self.sms_con.Enable()
			self.button_sms_identify.Disable()
			self.save_gammu_settings('', '')
			self.sms_enable_send.SetValue(False)
			self.onsms_enable_send(0)

	def onsms_enable_send(self, e):
		isChecked = self.sms_enable_send.GetValue()
		if isChecked:
			if not self.sms_enable.GetValue():
				self.ShowStatusBarBLACK(_('You have to enable settings.'))
				self.sms_enable_send.SetValue(False)
				return
			if self.phone_number.GetValue() == '':
				self.ShowStatusBarRED(_('You have to provide a phone number.'))
				self.sms_enable_send.SetValue(False)
				return
			self.conf.set('SMS', 'enable_sending', '1')
			self.conf.set('SMS', 'phone', self.phone_number.GetValue())
			self.phone_number_label.Disable()
			self.phone_number.Disable()
			self.sms_text_label.Enable()
			self.sms_text.Enable()
			self.button_sms_test.Enable()
		else:
			self.conf.set('SMS', 'enable_sending', '0')
			self.phone_number_label.Enable()
			self.phone_number.Enable()
			self.sms_text_label.Disable()
			self.sms_text.Disable()
			self.button_sms_test.Disable()

	def on_sms_identify(self, e):
		subprocess.call(['pkill', '-f', 'test_sms.py'])
		subprocess.Popen(['python', self.currentpath + '/test_sms.py', 'i', '0', '0'])

	def on_sms_test(self, e):
		text = self.sms_text.GetValue()
		if text == '':
			self.ShowStatusBarRED(_('You have to provide some text to send.'))
			return
		subprocess.call(['pkill', '-f', 'test_sms.py'])
		subprocess.Popen(['python', self.currentpath + '/test_sms.py', 't', text, self.phone_number.GetValue()])

	####################### MQTT
	def page_mqtt(self):
		title = wx.StaticText(self.p_mqtt, label=_(' MQTT '))

		self.mqtt_broker_t = wx.StaticText(self.p_mqtt, label=_('Remote broker'))
		self.mqtt_broker = wx.TextCtrl(self.p_mqtt, size=(190, -1))
		self.mqtt_port_t = wx.StaticText(self.p_mqtt, label=_('Port'))
		self.mqtt_port = wx.TextCtrl(self.p_mqtt, size=(50, -1))
		self.mqtt_user_t = wx.StaticText(self.p_mqtt, label=_('Username'))
		self.mqtt_user = wx.TextCtrl(self.p_mqtt, size=(120, -1))
		self.mqtt_pass_t = wx.StaticText(self.p_mqtt, label=_('Password'))
		self.mqtt_pass = wx.TextCtrl(self.p_mqtt, size=(120, -1))

		self.button_apply_changes_mqtt = wx.Button(self.p_mqtt, label=_('Apply'))
		self.button_apply_changes_mqtt.Bind(wx.EVT_BUTTON, self.on_apply_changes_mqtt)

		clear = wx.Button(self.p_mqtt, label=_('Clear'))
		clear.Bind(wx.EVT_BUTTON, self.on_clear_mqtt)

		self.list_topics = wx.ListCtrl(self.p_mqtt, -1, style=wx.LC_REPORT | wx.SUNKEN_BORDER)
		self.list_topics.InsertColumn(1, _('Topic'), width=565)
		self.list_topics.Bind(wx.EVT_LIST_ITEM_ACTIVATED, self.edit_topic)

		add = wx.Button(self.p_mqtt, label=_('add'))
		add.Bind(wx.EVT_BUTTON, self.on_add_topic)

		delete = wx.Button(self.p_mqtt, label=_('delete'))
		delete.Bind(wx.EVT_BUTTON, self.delete_topic)

		diagnostic = wx.Button(self.p_mqtt, label=_('SK Diagnostic'))
		diagnostic.Bind(wx.EVT_BUTTON, self.on_diagnostic_SK)

		vboxc1 = wx.BoxSizer(wx.VERTICAL)
		vboxc1.Add(self.mqtt_broker_t, 0, wx.RIGHT | wx.LEFT, 5)
		vboxc1.Add(self.mqtt_broker, 0, wx.RIGHT | wx.LEFT, 5)

		vboxc2 = wx.BoxSizer(wx.VERTICAL)
		vboxc2.Add(self.mqtt_port_t, 0, wx.RIGHT | wx.LEFT, 5)
		vboxc2.Add(self.mqtt_port, 0, wx.RIGHT | wx.LEFT, 5)

		vboxc3 = wx.BoxSizer(wx.VERTICAL)
		vboxc3.Add(self.mqtt_user_t, 0, wx.RIGHT | wx.LEFT, 5)
		vboxc3.Add(self.mqtt_user, 0, wx.RIGHT | wx.LEFT, 5)

		vboxc4 = wx.BoxSizer(wx.VERTICAL)
		vboxc4.Add(self.mqtt_pass_t, 0, wx.RIGHT | wx.LEFT, 5)
		vboxc4.Add(self.mqtt_pass, 0, wx.RIGHT | wx.LEFT, 5)

		vboxc5but = wx.BoxSizer(wx.VERTICAL)
		vboxc5but.Add(self.button_apply_changes_mqtt, 0, wx.ALL | wx.EXPAND, 5)
		vboxc5but.Add(clear, 0, wx.ALL | wx.EXPAND, 5)

		hinputbox = wx.BoxSizer(wx.HORIZONTAL)
		hinputbox.Add(vboxc1, 0, wx.ALL | wx.EXPAND, 5)
		hinputbox.Add(vboxc2, 0, wx.ALL | wx.EXPAND, 5)
		hinputbox.Add(vboxc3, 0, wx.ALL | wx.EXPAND, 5)
		hinputbox.Add(vboxc4, 0, wx.ALL | wx.EXPAND, 5)
		hinputbox.Add((0, 0), 1, wx.EXPAND)
		hinputbox.Add(vboxc5but, 0, wx.RIGHT | wx.LEFT, 0)

		hlistbox_but = wx.BoxSizer(wx.VERTICAL)
		hlistbox_but.Add(add, 0, wx.ALL, 5)
		hlistbox_but.Add(delete, 0, wx.ALL, 5)

		hlistbox = wx.BoxSizer(wx.HORIZONTAL)
		hlistbox.Add(self.list_topics, 1, wx.ALL | wx.EXPAND, 5)
		hlistbox.Add(hlistbox_but, 0, wx.RIGHT | wx.LEFT, 0)

		hbox = wx.BoxSizer(wx.HORIZONTAL)
		hbox.Add(diagnostic, 0, wx.RIGHT | wx.LEFT, 5)

		vbox = wx.BoxSizer(wx.VERTICAL)
		vbox.Add(title, 0, wx.ALL | wx.EXPAND, 5)
		vbox.Add(hinputbox, 0, wx.ALL | wx.EXPAND, 0)
		vbox.AddSpacer(5)
		vbox.Add(hlistbox, 1, wx.ALL | wx.EXPAND, 0)
		vbox.Add(hbox, 0, wx.ALL | wx.EXPAND, 0)

		self.p_mqtt.SetSizer(vbox)

	def start_mqtt(self):
		subprocess.Popen(['python', self.currentpath + '/mqtt_d.py'])

	def stop_mqtt(self):
		subprocess.call(['pkill', '-f', 'mqtt_d.py'])

	def read_mqtt(self):
		broker = self.conf.get('MQTT', 'broker')
		port = self.conf.get('MQTT', 'port')
		username = self.conf.get('MQTT', 'username')
		password = self.conf.get('MQTT', 'password')
		if broker: self.mqtt_broker.SetValue(broker)
		if port: self.mqtt_port.SetValue(port)
		if username: self.mqtt_user.SetValue(username)
		if password: self.mqtt_pass.SetValue('***************')
		if username and password:
			self.mqtt_broker.Disable()
			self.mqtt_port.Disable()
			self.mqtt_user.Disable()
			self.mqtt_pass.Disable()
			self.button_apply_changes_mqtt.SetLabel(_('Edit'))
		else:
			self.mqtt_broker.Enable()
			self.mqtt_port.Enable()
			self.mqtt_user.Enable()
			self.mqtt_pass.Enable()
			self.button_apply_changes_mqtt.SetLabel(_('Apply'))
		self.topics = []
		self.list_topics.DeleteAllItems()
		data = self.conf.get('MQTT', 'topics')
		try:
			temp_list = eval(data)
		except:
			temp_list = []
		for ii in temp_list:
			self.topics.append(ii)
			self.list_topics.Append([ii])

	def edit_topic(self, e):
		selected_topic = e.GetIndex()
		edit = [selected_topic, self.topics[selected_topic]]
		self.edit_add_topic(edit)

	def on_add_topic(self, e):
		self.edit_add_topic(0)

	def edit_add_topic(self, edit):
		if self.mqtt_user.IsEnabled():
			self.ShowStatusBarRED(_('Failed. Apply setting changes.'))
			return
		dlg = addTopic(edit)
		res = dlg.ShowModal()
		if res == wx.ID_OK:
			topic = dlg.topic.GetValue()
			topic = topic.encode('utf8')
			if not topic:
				self.ShowMessage(_('Failed. Write a topic.'))
				dlg.Destroy()
				return
			if not re.match('^[0-9a-zA-Z/]+$', topic):
				self.ShowMessage(_('Failed. Topics must contain only allowed characters.'))
				dlg.Destroy()
				return
			if edit == 0:
				self.list_topics.Append([topic])
				self.topics.append(topic)
			else:
				self.list_topics.SetStringItem(edit[0], 0, topic)
				self.topics[edit[0]] = topic
			self.conf.set('MQTT', 'topics', str(self.topics))
			self.restart_SK(0)
		dlg.Destroy()

	def delete_topic(self, e):
		if self.mqtt_user.IsEnabled():
			self.ShowStatusBarRED(_('Failed. Apply setting changes.'))
			return
		selected_topic = self.list_topics.GetFirstSelected()
		if selected_topic == -1:
			self.ShowStatusBarBLACK(_('Select an item to delete.'))
			return
		del self.topics[selected_topic]
		self.list_topics.DeleteItem(selected_topic)
		self.conf.set('MQTT', 'topics', str(self.topics))
		self.restart_SK(0)

	def on_apply_changes_mqtt(self, e):
		if not self.mqtt_user.IsEnabled():
			self.mqtt_broker.Enable()
			self.mqtt_port.Enable()
			self.mqtt_user.Enable()
			self.mqtt_pass.Enable()
			self.button_apply_changes_mqtt.SetLabel(_('Apply'))
			return
		username = self.mqtt_user.GetValue()
		passw = self.mqtt_pass.GetValue()
		if username and passw:
			self.mqtt_broker.Disable()
			self.mqtt_port.Disable()
			self.mqtt_user.Disable()
			self.mqtt_pass.Disable()
			self.button_apply_changes_mqtt.SetLabel(_('Edit'))
		else:
			self.ShowStatusBarRED(_('Enter at least username and password.'))
			return
		self.conf.set('MQTT', 'broker', self.mqtt_broker.GetValue())
		self.conf.set('MQTT', 'port', self.mqtt_port.GetValue())
		self.conf.set('MQTT', 'username', username)
		if not '*******' in passw:
			self.mqtt_pass.SetValue('***************')
			self.conf.set('MQTT', 'password', passw)
		else:
			passw = self.conf.get('MQTT', 'password')
		subprocess.call(['sudo', 'sh', '-c', 'echo "' + username + ':' + passw + '" > /etc/mosquitto/passwd.pw'])
		subprocess.call(['sudo', 'mosquitto_passwd', '-U', '/etc/mosquitto/passwd.pw'])
		subprocess.call(['sudo', 'service', 'mosquitto', 'restart'])
		self.ShowStatusBarGREEN(_('MQTT settings applied and restarted'))
		self.stop_mqtt()
		self.start_mqtt()

	def on_clear_mqtt(self, e):
		dlg = wx.MessageDialog(None, _('Settings and topics will be deleted. Are you sure?'), _('Question'),
							   wx.YES_NO | wx.NO_DEFAULT | wx.ICON_QUESTION)
		if dlg.ShowModal() != wx.ID_YES:
			dlg.Destroy()
			return
		dlg.Destroy()
		self.mqtt_broker.Enable()
		self.mqtt_port.Enable()
		self.mqtt_user.Enable()
		self.mqtt_pass.Enable()
		self.button_apply_changes_mqtt.SetLabel(_('Apply'))
		self.mqtt_broker.SetValue('')
		self.mqtt_port.SetValue('')
		self.mqtt_user.SetValue('')
		self.mqtt_pass.SetValue('')
		self.list_topics.DeleteAllItems()
		self.topics = []
		self.conf.set('MQTT', 'broker', '')
		self.conf.set('MQTT', 'port', '')
		self.conf.set('MQTT', 'username', '')
		self.conf.set('MQTT', 'password', '')
		self.conf.set('MQTT', 'topics', '')
		self.restart_SK(0)


############################## Main
if __name__ == "__main__":
	app = wx.App()

	bitmap = wx.Bitmap(Paths().home + '/.config/openplotter/openplotter.ico', wx.BITMAP_TYPE_ICO)
	splash = wx.SplashScreen(bitmap, wx.SPLASH_CENTRE_ON_SCREEN | wx.SPLASH_TIMEOUT, 500, None,
							 style=wx.SIMPLE_BORDER | wx.STAY_ON_TOP)
	wx.Yield()

	MainFrame().Show()
	app.MainLoop()
